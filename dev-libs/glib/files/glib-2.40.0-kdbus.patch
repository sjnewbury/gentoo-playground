diff --git a/configure.ac b/configure.ac
index a01e58d..1716d53 100644
--- a/configure.ac
+++ b/configure.ac
@@ -231,6 +231,10 @@ AC_ARG_ENABLE(gc_friendly,
               [AS_HELP_STRING([--enable-gc-friendly],
                               [turn on garbage collector friendliness [default=no]])],,
               [enable_gc_friendly=no])
+AC_ARG_ENABLE(kdbus_transport,
+              [AS_HELP_STRING([--enable-kdbus-transport],
+                             [enable kdbus transport [default=no]])],,
+              [enable_kdbus_transport=no])
 AC_ARG_ENABLE(mem_pools,
               [AS_HELP_STRING([--disable-mem-pools],
 			      [disable all glib memory pools])],,
@@ -248,6 +252,13 @@ AS_IF([test "x$enable_gc_friendly" = "xyes"], [
   AC_MSG_RESULT([yes])
 ], [ AC_MSG_RESULT([no]) ])
 
+AC_MSG_CHECKING([kdbus transport])
+AM_CONDITIONAL(KDBUS_TRANSPORT, [test "x$enable_kdbus_transport" = "xyes"])
+AS_IF([test "x$enable_kdbus_transport" = "xyes"], [
+  AC_DEFINE(KDBUS_TRANSPORT, 1, [Define if kdbus transport is enabled])
+  AC_MSG_RESULT([yes])
+], [ AC_MSG_RESULT([no]) ])
+
 AC_MSG_CHECKING([whether to disable memory pools])
 AS_IF([test "x$disable_mem_pools" = "xno"], [
   AC_MSG_RESULT([no])
diff --git a/gio/Makefile.am b/gio/Makefile.am
index e993e2f..e4c05f8 100644
--- a/gio/Makefile.am
+++ b/gio/Makefile.am
@@ -395,6 +395,8 @@ libgio_2_0_la_SOURCES =		\
 	gioprivate.h		\
 	giowin32-priv.h 	\
 	gloadableicon.c 	\
+	gkdbus.c                \
+	gkdbusconnection.c	\
 	gmount.c 		\
 	gmemoryinputstream.c 	\
 	gmemoryoutputstream.c 	\
@@ -569,6 +571,9 @@ gio_headers =			\
 	giomodule.h 		\
 	gioscheduler.h 		\
 	giostream.h		\
+	gkdbus.h                \
+	gdbusprivate.h		\
+	gkdbusconnection.h	\
 	gloadableicon.h 	\
 	gmount.h 		\
 	gmemoryinputstream.h 	\
diff --git a/gio/gdbusaddress.c b/gio/gdbusaddress.c
index 6d17b7c..4920898 100644
--- a/gio/gdbusaddress.c
+++ b/gio/gdbusaddress.c
@@ -1,6 +1,7 @@
 /* GDBus - GLib D-Bus Library
  *
  * Copyright (C) 2008-2010 Red Hat, Inc.
+ * Copyright (C) 2013 Samsung Electronics
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -15,7 +16,9 @@
  * You should have received a copy of the GNU Lesser General
  * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
  *
- * Author: David Zeuthen <davidz@redhat.com>
+ * Author: David Zeuthen        <davidz@redhat.com>
+ * Author: Lukasz Skalski       <l.skalski@samsung.com>
+ * Author: Michal Eljasiewicz   <m.eljasiewic@samsung.com>
  */
 
 #include "config.h"
@@ -42,6 +45,7 @@
 
 #ifdef G_OS_UNIX
 #include <gio/gunixsocketaddress.h>
+#include <gio/gkdbusconnection.h>
 #endif
 
 #ifdef G_OS_WIN32
@@ -358,6 +362,18 @@ is_valid_tcp (const gchar  *address_entry,
   return ret;
 }
 
+static int
+g_dbus_is_supported_address_kdbus (const gchar  *transport_name)
+{
+  int supported = 0;
+
+#if defined (G_OS_UNIX) && (KDBUS_TRANSPORT)
+  supported = g_strcmp0 (transport_name, "kernel") == 0;
+#endif
+
+  return supported;
+}
+
 /**
  * g_dbus_is_supported_address:
  * @string: A string.
@@ -399,7 +415,8 @@ g_dbus_is_supported_address (const gchar  *string,
         goto out;
 
       supported = FALSE;
-      if (g_strcmp0 (transport_name, "unix") == 0)
+      if ((g_strcmp0 (transport_name, "unix") == 0)
+          || g_dbus_is_supported_address_kdbus (transport_name))
         supported = is_valid_unix (a[n], key_value_pairs, error);
       else if (g_strcmp0 (transport_name, "tcp") == 0)
         supported = is_valid_tcp (a[n], key_value_pairs, error);
@@ -551,7 +568,8 @@ g_dbus_address_connect (const gchar   *address_entry,
     {
     }
 #ifdef G_OS_UNIX
-  else if (g_strcmp0 (transport_name, "unix") == 0)
+  if ((g_strcmp0 (transport_name, "unix") == 0)
+      || g_dbus_is_supported_address_kdbus (transport_name))
     {
       const gchar *path;
       const gchar *abstract;
@@ -662,21 +680,51 @@ g_dbus_address_connect (const gchar   *address_entry,
 
   if (connectable != NULL)
     {
-      GSocketClient *client;
-      GSocketConnection *connection;
 
-      g_assert (ret == NULL);
-      client = g_socket_client_new ();
-      connection = g_socket_client_connect (client,
-                                            connectable,
-                                            cancellable,
-                                            error);
-      g_object_unref (connectable);
-      g_object_unref (client);
-      if (connection == NULL)
-        goto out;
+      if (FALSE)
+        {
+        }
+#if defined (G_OS_UNIX) && (KDBUS_TRANSPORT)
+      else if (g_dbus_is_supported_address_kdbus (transport_name))
+        {
+          GKdbusConnection *connection;
+          gboolean status;
+
+          const gchar *path;
+          path = g_hash_table_lookup (key_value_pairs, "path");
 
-      ret = G_IO_STREAM (connection);
+          g_assert (ret == NULL);
+          connection = _g_kdbus_connection_new ();
+          status = _g_kdbus_connection_connect (connection,
+                                                path,
+                                                cancellable,
+                                                error);
+          g_object_unref (connectable);
+
+          if (!status)
+            goto out;
+
+          ret = G_IO_STREAM (connection);
+        }
+#endif
+      else
+        {
+          GSocketClient *client;
+          GSocketConnection *connection;
+
+          g_assert (ret == NULL);
+          client = g_socket_client_new ();
+          connection = g_socket_client_connect (client,
+                                                connectable,
+                                                cancellable,
+                                                error);
+          g_object_unref (connectable);
+          g_object_unref (client);
+          if (connection == NULL)
+            goto out;
+
+          ret = G_IO_STREAM (connection);
+        }
 
       if (nonce_file != NULL)
         {
@@ -1512,7 +1560,11 @@ g_dbus_address_get_for_bus_sync (GBusType       bus_type,
       ret = g_strdup (g_getenv ("DBUS_SYSTEM_BUS_ADDRESS"));
       if (ret == NULL)
         {
+#if defined (G_OS_UNIX) && (KDBUS_TRANSPORT)
+          ret = g_strdup ("kernel:path=/dev/kdbus/0-system/bus;unix:path=/var/run/dbus/system_bus_socket");
+#else
           ret = g_strdup ("unix:path=/var/run/dbus/system_bus_socket");
+#endif
         }
       break;
 
@@ -1520,7 +1572,11 @@ g_dbus_address_get_for_bus_sync (GBusType       bus_type,
       ret = g_strdup (g_getenv ("DBUS_SESSION_BUS_ADDRESS"));
       if (ret == NULL)
         {
+#if defined (G_OS_UNIX) && (KDBUS_TRANSPORT)
+          ret = g_strdup_printf ("kernel:path=/dev/kdbus/%d-user/bus;unix:path=%s/bus", getuid(), g_getenv ("XDG_RUNTIME_DIR"));
+#else
           ret = get_session_address_platform_specific (&local_error);
+#endif
         }
       break;
 
diff --git a/gio/gdbusconnection.c b/gio/gdbusconnection.c
index fc9acbe..5102cf6 100644
--- a/gio/gdbusconnection.c
+++ b/gio/gdbusconnection.c
@@ -1,6 +1,7 @@
 /* GDBus - GLib D-Bus Library
  *
  * Copyright (C) 2008-2010 Red Hat, Inc.
+ * Copyright (C) 2013 Samsung Electronics
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -15,7 +16,9 @@
  * You should have received a copy of the GNU Lesser General
  * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
  *
- * Author: David Zeuthen <davidz@redhat.com>
+ * Author: David Zeuthen        <davidz@redhat.com>
+ * Author: Lukasz Skalski       <l.skalski@samsung.com>
+ * Author: Michal Eljasiewicz   <m.eljasiewic@samsung.com>
  */
 
 /*
@@ -122,6 +125,7 @@
 #include "gsimpleasyncresult.h"
 
 #ifdef G_OS_UNIX
+#include "gkdbusconnection.h"
 #include "gunixconnection.h"
 #include "gunixfdmessage.h"
 #endif
@@ -1656,6 +1660,21 @@ g_dbus_connection_send_message_unlocked (GDBusConnection   *connection,
                        error))
     goto out;
 
+  /* [KDBUS]
+   * Setting protocol version, before invoking g_dbus_message_to_blob() will
+   * be removed after preparing new function only for kdbus transport purposes
+   * (this function will be able to create blob directly/unconditionally in memfd
+   * object, without making copy), but memfd will be completly reworked soon [1],
+   * so we're still waiting for this:
+   *
+   * [1] https://code.google.com/p/d-bus/source/browse/TODO
+   */
+
+  if (G_IS_KDBUS_CONNECTION (connection->stream))
+    _g_dbus_message_set_protocol_ver (message,2);
+  else
+    _g_dbus_message_set_protocol_ver (message,1);
+
   blob = g_dbus_message_to_blob (message,
                                  &blob_size,
                                  connection->capabilities,
@@ -2512,10 +2531,17 @@ get_offered_capabilities_max (GDBusConnection *connection)
 {
       GDBusCapabilityFlags ret;
       ret = G_DBUS_CAPABILITY_FLAGS_NONE;
+
 #ifdef G_OS_UNIX
       if (G_IS_UNIX_CONNECTION (connection->stream))
         ret |= G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING;
-#endif
+
+#ifdef KDBUS_TRANSPORT
+      if (G_IS_KDBUS_CONNECTION (connection->stream))
+        ret |= G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING;
+#endif /* KDBUS_TRANSPORT */
+
+#endif /* G_OS_UNIX */
       return ret;
 }
 
@@ -2591,6 +2617,13 @@ initable_init (GInitable     *initable,
       g_assert_not_reached ();
     }
 
+  /* [KDBUS] Skip authentication process for kdbus transport */
+  if (G_IS_KDBUS_CONNECTION (connection->stream))
+    {
+      connection->capabilities = get_offered_capabilities_max (connection);
+      goto authenticated;
+    }
+
   /* Authenticate the connection */
   if (connection->flags & G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER)
     {
@@ -2629,6 +2662,8 @@ initable_init (GInitable     *initable,
       connection->authentication_observer = NULL;
     }
 
+authenticated:
+
   //g_output_stream_flush (G_SOCKET_CONNECTION (connection->stream)
 
   //g_debug ("haz unix fd passing powers: %d", connection->capabilities & G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING);
@@ -3725,7 +3760,7 @@ emit_signal_instance_in_idle_cb (gpointer data)
     }
   else
     {
-      g_variant_ref_sink (parameters);
+      g_variant_ref (parameters);
     }
 
 #if 0
diff --git a/gio/gdbusmessage.c b/gio/gdbusmessage.c
index 824245e..d52dc0e 100644
--- a/gio/gdbusmessage.c
+++ b/gio/gdbusmessage.c
@@ -49,6 +49,7 @@
 #include "gdbusprivate.h"
 
 #ifdef G_OS_UNIX
+#include "gkdbus.h"
 #include "gunixfdlist.h"
 #endif
 
@@ -1019,6 +1020,38 @@ g_dbus_message_set_serial (GDBusMessage  *message,
 
 /* ---------------------------------------------------------------------------------------------------- */
 
+/**
+  * _g_dbus_message_get_protocol_ver:
+  * To remove - more info [1]
+  * [1] https://bugzilla.gnome.org/show_bug.cgi?id=721861
+  */
+guint32
+_g_dbus_message_get_protocol_ver (GDBusMessage *message)
+{
+  g_return_val_if_fail (G_IS_DBUS_MESSAGE (message), 0);
+  return message->major_protocol_version;
+}
+
+/**
+  * _g_dbus_message_set_protocol_ver:
+  * To remove - more info [1]
+  * [1] https://bugzilla.gnome.org/show_bug.cgi?id=721861
+  */
+void
+_g_dbus_message_set_protocol_ver (GDBusMessage  *message,
+                                  guint32        protocol_ver)
+{
+  g_return_if_fail (G_IS_DBUS_MESSAGE (message));
+
+  if (message->locked)
+    {
+      g_warning ("%s: Attempted to modify a locked message", G_STRFUNC);
+      return;
+    }
+
+  message->major_protocol_version = protocol_ver;
+}
+
 /* TODO: need GI annotations to specify that any guchar value goes for header_field */
 
 /**
@@ -1349,7 +1382,7 @@ validate_headers (GDBusMessage  *message,
 /* ---------------------------------------------------------------------------------------------------- */
 
 static gboolean
-ensure_input_padding (GMemoryBuffer         *buf,
+ensure_input_padding (GMemoryBuffer        *buf,
                       gsize                 padding_size,
                       GError              **error)
 {
@@ -2201,6 +2234,219 @@ g_dbus_message_new_from_blob (guchar                *blob,
 
 /* ---------------------------------------------------------------------------------------------------- */
 
+/*
+ * _g_dbus_message_new_from_kdbus_items:
+ *
+ * Single kdbus message may contain zero, one or more items
+ * (PAYLOAD_VEC or PAYLOAD_MEMFD), so we need this function
+ * (only for kdbus transport purposes) to parse them to GDBusMessage.
+ * kdbus_msg_items list contain list of pointer + data pair for each received item.
+ *
+ * TODO: Add support for two and more items
+ */
+
+GDBusMessage *
+_g_dbus_message_new_from_kdbus_items (GSList  *kdbus_msg_items,
+                                      GError **error)
+{
+  gboolean ret;
+  GMemoryBuffer mbuf;
+  GDBusMessage *message;
+  guchar endianness;
+  guchar major_protocol_version;
+  guint32 message_body_len;
+  guint32 message_headers_len;
+  GVariant *headers;
+  GVariant *item;
+  GVariantIter iter;
+  GVariant *signature;
+
+  ret = FALSE;
+
+  g_return_val_if_fail (kdbus_msg_items != NULL, NULL);
+  g_return_val_if_fail (error == NULL || *error == NULL, NULL);
+
+  message = g_dbus_message_new ();
+  memset (&mbuf, 0, sizeof (mbuf));
+
+  /*
+   * MESSAGE HEADER
+   * message header in its entirety must be contained in a first single item
+   */
+  mbuf.data = ((msg_part*)kdbus_msg_items->data)->data;
+  mbuf.len = mbuf.valid_len = ((msg_part*)kdbus_msg_items->data)->size;
+
+  endianness = g_memory_buffer_read_byte (&mbuf, NULL);
+  switch (endianness)
+    {
+    case 'l':
+      mbuf.byte_order = G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN;
+      message->byte_order = G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN;
+      break;
+    case 'B':
+      mbuf.byte_order = G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN;
+      message->byte_order = G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN;
+      break;
+    default:
+      g_set_error (error,
+                   G_IO_ERROR,
+                   G_IO_ERROR_INVALID_ARGUMENT,
+                   _("Invalid endianness value. Expected 0x6c ('l') or 0x42 ('B') but found value 0x%02x"),
+                   endianness);
+      goto out;
+    }
+
+  message->type = g_memory_buffer_read_byte (&mbuf, NULL);
+  message->flags = g_memory_buffer_read_byte (&mbuf, NULL);
+  major_protocol_version = g_memory_buffer_read_byte (&mbuf, NULL);
+
+  if (major_protocol_version != 2)
+    {
+      g_set_error (error,
+                   G_IO_ERROR,
+                   G_IO_ERROR_INVALID_ARGUMENT,
+                   _("Invalid major protocol version. Expected 2 but found %d"),
+                   major_protocol_version);
+      goto out;
+    }
+
+  message_body_len = g_memory_buffer_read_uint32 (&mbuf, NULL);
+  message->serial = g_memory_buffer_read_uint32 (&mbuf, NULL);
+
+  message_headers_len = g_memory_buffer_read_uint32 (&mbuf, NULL);
+  headers = g_variant_new_from_data (G_VARIANT_TYPE ("a{yv}"),
+                                     mbuf.data + mbuf.pos,
+                                     message_headers_len,
+                                     TRUE,
+                                     NULL,
+                                     NULL);
+  mbuf.pos += message_headers_len;
+
+  if (headers == NULL)
+    goto out;
+  g_variant_iter_init (&iter, headers);
+  while ((item = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      guchar header_field;
+      GVariant *value;
+      g_variant_get (item,
+                     "{yv}",
+                     &header_field,
+                     &value);
+      g_dbus_message_set_header (message, header_field, value);
+      g_variant_unref (value);
+      g_variant_unref (item);
+    }
+  g_variant_unref (headers);
+
+  signature = g_dbus_message_get_header (message, G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE);
+  if (signature != NULL)
+    {
+      const gchar *signature_str;
+      gsize signature_str_len;
+
+      signature_str = g_variant_get_string (signature, &signature_str_len);
+
+      if (signature_str_len > 0)
+        {
+          GVariantType *variant_type;
+          gchar *tupled_signature_str;
+
+          gchar *data = NULL;
+          gsize size = NULL;
+
+          if (!g_variant_is_signature (signature_str))
+            {
+              g_set_error (error,
+                           G_IO_ERROR,
+                           G_IO_ERROR_INVALID_ARGUMENT,
+                           _("Parsed value '%s' is not a valid D-Bus signature (for body)"),
+                           signature_str);
+              goto out;
+            }
+          tupled_signature_str = g_strdup_printf ("(%s)", signature_str);
+          variant_type = g_variant_type_new (tupled_signature_str);
+          g_free (tupled_signature_str);
+
+          /*
+           * MESSAGE BODY
+           */
+
+          if (g_slist_length(kdbus_msg_items) == 1)
+            {
+              /* if kdbus_msg_items has only one element, head and body are
+                 contained in a single PAYLOAD_VEC item */
+              ensure_input_padding (&mbuf,8,NULL);
+              data = mbuf.data + mbuf.pos;
+              size = message_body_len;
+            }
+          else if (g_slist_length(kdbus_msg_items) > 1)
+            {
+              /* message consists two or more items
+                 TODO: Add support for three and more items */
+              data = ((msg_part*)g_slist_next(kdbus_msg_items)->data)->data;
+              size = ((msg_part*)g_slist_next(kdbus_msg_items)->data)->size;
+            }
+          else
+            {
+              g_set_error (error,
+                           G_IO_ERROR,
+                           G_IO_ERROR_INVALID_ARGUMENT,
+                           _("[KDBUS] Received message is not valid"));
+              goto out;
+            }
+
+          message->body = g_variant_new_from_data (variant_type,
+                                                   data,
+                                                   size,
+                                                   TRUE,
+                                                   NULL,
+                                                   NULL);
+
+          g_variant_type_free (variant_type);
+          if (message->body == NULL)
+            goto out;
+        }
+    }
+  else
+    {
+      /* no signature, this is only OK if the body is empty */
+      if (message_body_len != 0)
+        {
+          /* G_GUINT32_FORMAT doesn't work with gettext, just use %u */
+          g_set_error (error,
+                       G_IO_ERROR,
+                       G_IO_ERROR_INVALID_ARGUMENT,
+                       g_dngettext (GETTEXT_PACKAGE,
+                                    "No signature header in message but the message body is %u byte",
+                                    "No signature header in message but the message body is %u bytes",
+                                    message_body_len),
+                       message_body_len);
+          goto out;
+        }
+    }
+
+  if (!validate_headers (message, error))
+    {
+      g_prefix_error (error, _("Cannot deserialize message: "));
+      goto out;
+    }
+
+  ret = TRUE;
+
+ out:
+  if (ret)
+    {
+      return message;
+    }
+  else
+    {
+      if (message != NULL)
+        g_object_unref (message);
+      return NULL;
+    }
+}
+
 static gsize
 ensure_output_padding (GMemoryBuffer  *mbuf,
                        gsize                 padding_size)
@@ -2556,6 +2802,15 @@ append_body_to_blob (GVariant             *value,
 
 /* ---------------------------------------------------------------------------------------------------- */
 
+/* [KDBUS]
+ * g_dbus_message_to_blob() will be replaced by new function only for kdbus transport
+ * purposes (this function will be able to create blob directly/unconditionally in memfd
+ * object, without making copy), but memfd will be completly reworked soon [1],
+ * so we're still waiting for this:
+ *
+ * [1] https://code.google.com/p/d-bus/source/browse/TODO
+ */
+
 /**
  * g_dbus_message_to_blob:
  * @message: A #GDBusMessage.
@@ -2584,7 +2839,11 @@ g_dbus_message_to_blob (GDBusMessage          *message,
   goffset body_len_offset;
   goffset body_start_offset;
   gsize body_size;
+  gconstpointer message_body_data;
+  gsize message_body_size;
   GVariant *header_fields;
+  gsize header_fields_size;
+  gconstpointer header_fields_data;
   GVariantBuilder builder;
   GHashTableIter hash_iter;
   gpointer key;
@@ -2602,6 +2861,20 @@ g_dbus_message_to_blob (GDBusMessage          *message,
   g_return_val_if_fail (out_size != NULL, NULL);
   g_return_val_if_fail (error == NULL || *error == NULL, NULL);
 
+  /* temporary solution */
+  if (!message->major_protocol_version)
+    g_error ("message->major_protocol_version is not set");
+
+  if (message->major_protocol_version != 1 && message->major_protocol_version != 2)
+    {
+      g_set_error (error,
+                   G_IO_ERROR,
+                   G_IO_ERROR_INVALID_ARGUMENT,
+                   _("Invalid major protocol version. Expected 1 or 2 but found %d"),
+                   message->major_protocol_version);
+      goto out;
+    }
+
   memset (&mbuf, 0, sizeof (mbuf));
   mbuf.len = MIN_ARRAY_SIZE;
   mbuf.data = g_malloc (mbuf.len);
@@ -2621,7 +2894,10 @@ g_dbus_message_to_blob (GDBusMessage          *message,
   g_memory_buffer_put_byte (&mbuf, (guchar) message->byte_order);
   g_memory_buffer_put_byte (&mbuf, message->type);
   g_memory_buffer_put_byte (&mbuf, message->flags);
-  g_memory_buffer_put_byte (&mbuf, 1); /* major protocol version */
+
+  /* major protocol version */
+  g_memory_buffer_put_byte (&mbuf, message->major_protocol_version);
+
   body_len_offset = mbuf.valid_len;
   /* body length - will be filled in later */
   g_memory_buffer_put_uint32 (&mbuf, 0xF00DFACE);
@@ -2661,15 +2937,30 @@ g_dbus_message_to_blob (GDBusMessage          *message,
     }
   header_fields = g_variant_builder_end (&builder);
 
-  if (!append_value_to_blob (header_fields,
-                             g_variant_get_type (header_fields),
-                             &mbuf,
-                             NULL,
-                             error))
+  /* header - dbus1 marshaliling */
+  if (message->major_protocol_version == 1)
     {
-      g_variant_unref (header_fields);
-      goto out;
+      if (!append_value_to_blob (header_fields,
+                                 g_variant_get_type (header_fields),
+                                 &mbuf,
+                                 NULL,
+                                 error))
+        {
+          g_variant_unref (header_fields);
+          goto out;
+        }
+
     }
+  /* header - GVariant marshalling */
+  else if (message->major_protocol_version == 2)
+    {
+      header_fields_data = g_variant_get_data (header_fields);
+      header_fields_size = g_variant_get_size (header_fields);
+
+      g_memory_buffer_put_uint32 (&mbuf, header_fields_size);
+      g_memory_buffer_write (&mbuf, header_fields_data, header_fields_size);
+    }
+
   g_variant_unref (header_fields);
 
   /* header size must be a multiple of 8 */
@@ -2706,8 +2997,21 @@ g_dbus_message_to_blob (GDBusMessage          *message,
           goto out;
         }
       g_free (tupled_signature_str);
-      if (!append_body_to_blob (message->body, &mbuf, error))
-        goto out;
+
+      /* body - dbus1 marshaliling */
+      if (message->major_protocol_version == 1)
+        {
+          if (!append_body_to_blob (message->body, &mbuf, error))
+            goto out;
+        }
+      /* body - GVariant marshalling */
+      else if (message->major_protocol_version == 2)
+        {
+          message_body_data = g_variant_get_data (message->body);
+          message_body_size = g_variant_get_size (message->body);
+
+          g_memory_buffer_write (&mbuf, message_body_data, message_body_size);
+        }
     }
   else
     {
diff --git a/gio/gdbusmessage.h b/gio/gdbusmessage.h
index f791889..8f9b25e 100644
--- a/gio/gdbusmessage.h
+++ b/gio/gdbusmessage.h
@@ -192,6 +192,16 @@ GLIB_AVAILABLE_IN_ALL
 gboolean                  g_dbus_message_to_gerror          (GDBusMessage             *message,
                                                              GError                  **error);
 
+GDBusMessage             *_g_dbus_message_new_from_kdbus_items  (GSList               *kdbus_msg_items,
+                                                                 GError              **error);
+
+/* to remove */
+guint32                   _g_dbus_message_get_protocol_ver      (GDBusMessage             *message);
+
+/* to remove */
+void                      _g_dbus_message_set_protocol_ver      (GDBusMessage             *message,
+                                                                 guint32                   protocol_ver);
+
 G_END_DECLS
 
 #endif /* __G_DBUS_MESSAGE_H__ */
diff --git a/gio/gdbusprivate.c b/gio/gdbusprivate.c
index 762e676..1f03307 100644
--- a/gio/gdbusprivate.c
+++ b/gio/gdbusprivate.c
@@ -1,6 +1,7 @@
 /* GDBus - GLib D-Bus Library
  *
  * Copyright (C) 2008-2010 Red Hat, Inc.
+ * Copyright (C) 2013 Samsung Electronics
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -15,7 +16,9 @@
  * You should have received a copy of the GNU Lesser General
  * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
  *
- * Author: David Zeuthen <davidz@redhat.com>
+ * Author: David Zeuthen        <davidz@redhat.com>
+ * Author: Lukasz Skalski       <l.skalski@samsung.com>
+ * Author: Michal Eljasiewicz   <m.eljasiewicz@samsung.com>
  */
 
 #include "config.h"
@@ -40,6 +43,8 @@
 #include "gsocketoutputstream.h"
 
 #ifdef G_OS_UNIX
+#include "gkdbus.h"
+#include "gkdbusconnection.h"
 #include "gunixfdmessage.h"
 #include "gunixconnection.h"
 #include "gunixcredentialsmessage.h"
@@ -112,6 +117,107 @@ typedef struct
   gboolean from_mainloop;
 } ReadWithControlData;
 
+#if defined (G_OS_UNIX) && (KDBUS_TRANSPORT)
+typedef struct
+{
+  GKdbus *kdbus;
+  GCancellable *cancellable;
+
+  GSimpleAsyncResult *simple;
+
+  gboolean from_mainloop;
+} ReadKdbusData;
+
+static void
+read_kdbus_data_free (ReadKdbusData  *data)
+{
+  g_object_unref (data->kdbus);
+  if (data->cancellable != NULL)
+    g_object_unref (data->cancellable);
+  g_object_unref (data->simple);
+  g_free (data);
+}
+
+static gboolean
+_g_kdbus_read_ready (GKdbus        *kdbus,
+                     GIOCondition   condition,
+                     gpointer       user_data)
+{
+  ReadKdbusData *data = user_data;
+  GError *error = NULL;
+  gssize result;
+
+  result = _g_kdbus_receive (data->kdbus,
+                             data->cancellable,
+                             &error);
+
+  if (result >= 0)
+    {
+      g_simple_async_result_set_op_res_gssize (data->simple, result);
+    }
+  else
+    {
+      g_assert (error != NULL);
+      g_simple_async_result_take_error (data->simple, error);
+    }
+
+  if (data->from_mainloop)
+    g_simple_async_result_complete (data->simple);
+  else
+    g_simple_async_result_complete_in_idle (data->simple);
+
+  return FALSE;
+}
+
+static void
+_g_kdbus_read (GKdbus               *kdbus,
+               GCancellable         *cancellable,
+               GAsyncReadyCallback   callback,
+               gpointer              user_data)
+{
+  ReadKdbusData *data;
+  GSource *source;
+
+  data = g_new0 (ReadKdbusData, 1);
+  data->kdbus = g_object_ref (kdbus);
+  data->cancellable = cancellable != NULL ? g_object_ref (cancellable) : NULL;
+
+  data->simple = g_simple_async_result_new (G_OBJECT (kdbus),
+                                            callback,
+                                            user_data,
+                                            _g_kdbus_read);
+  g_simple_async_result_set_check_cancellable (data->simple, cancellable);
+
+  data->from_mainloop = TRUE;
+  source = _g_kdbus_create_source (data->kdbus,
+                                   G_IO_IN,
+                                   cancellable);
+  g_source_set_callback (source,
+                         (GSourceFunc) _g_kdbus_read_ready,
+                         data,
+                         (GDestroyNotify) read_kdbus_data_free);
+  g_source_attach (source, g_main_context_get_thread_default ());
+  g_source_unref (source);
+}
+
+static gssize
+_g_kdbus_read_finish (GKdbus        *kdbus,
+                      GAsyncResult  *result,
+                      GError       **error)
+{
+  GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  g_return_val_if_fail (G_IS_KDBUS (kdbus), -1);
+  g_warn_if_fail (g_simple_async_result_get_source_tag (simple) == _g_kdbus_read);
+
+  if (g_simple_async_result_propagate_error (simple, error))
+      return -1;
+  else
+    return g_simple_async_result_get_op_res_gssize (simple);
+}
+
+#endif /* defined (G_OS_UNIX) && (KDBUS_TRANSPORT) */
+
 static void
 read_with_control_data_free (ReadWithControlData *data)
 {
@@ -359,8 +465,11 @@ struct GDBusWorker
   GDBusWorkerDisconnectedCallback     disconnected_callback;
   gpointer                            user_data;
 
-  /* if not NULL, stream is GSocketConnection */
+  /* if GSocket and GKdbus are NULL, stream is GSocketConnection */
   GSocket *socket;
+#if defined (G_OS_UNIX) && (KDBUS_TRANSPORT)
+  GKdbus  *kdbus;
+#endif
 
   /* used for reading */
   GMutex                              read_lock;
@@ -371,6 +480,10 @@ struct GDBusWorker
   GUnixFDList                        *read_fd_list;
   GSocketControlMessage             **read_ancillary_messages;
   gint                                read_num_ancillary_messages;
+#if defined (G_OS_UNIX) && (KDBUS_TRANSPORT)
+  GSList                             *read_kdbus_msg_items;
+#endif
+
 
   /* Whether an async write, flush or close, or none of those, is pending.
    * Only the worker thread may change its value, and only with the write_lock.
@@ -501,7 +614,7 @@ _g_dbus_worker_emit_message_about_to_be_sent (GDBusWorker  *worker,
 }
 
 /* can only be called from private thread with read-lock held - takes ownership of @message */
-static void
+void
 _g_dbus_worker_queue_or_deliver_received_message (GDBusWorker  *worker,
                                                   GDBusMessage *message)
 {
@@ -579,7 +692,30 @@ _g_dbus_worker_do_read_cb (GInputStream  *input_stream,
     goto out;
 
   error = NULL;
-  if (worker->socket == NULL)
+  bytes_read = 0;
+
+  if (FALSE)
+    {
+    }
+#if defined (G_OS_UNIX) && (KDBUS_TRANSPORT)
+  else if (G_IS_KDBUS_CONNECTION (worker->stream))
+    {
+      /* bytes_read= 0 in case of any errors */
+      bytes_read = _g_kdbus_read_finish (worker->kdbus,
+                                         res,
+                                         &error);
+
+      /* [KDBUS]  Get all received items*/
+      worker->read_kdbus_msg_items = _g_kdbus_get_last_msg_items (worker->kdbus);
+
+      /* [KDBUS] Attach fds (if any) to worker->read_fd_list */
+      _g_kdbus_attach_fds_to_msg (worker->kdbus, &worker->read_fd_list);
+
+      /* [KDBUS] For KDBUS transport we read whole message at once*/
+      worker->read_buffer_bytes_wanted = bytes_read;
+    }
+#endif
+  else if (worker->socket == NULL)
     bytes_read = g_input_stream_read_finish (g_io_stream_get_input_stream (worker->stream),
                                              res,
                                              &error);
@@ -658,9 +794,8 @@ _g_dbus_worker_do_read_cb (GInputStream  *input_stream,
           _g_dbus_debug_print_lock ();
           g_print ("========================================================================\n"
                    "GDBus-debug:Transport:\n"
-                   "  ---- READ ERROR on stream of type %s:\n"
+                   "  ---- READ ERROR:\n"
                    "  ---- %s %d: %s\n",
-                   g_type_name (G_TYPE_FROM_INSTANCE (g_io_stream_get_input_stream (worker->stream))),
                    g_quark_to_string (error->domain), error->code,
                    error->message);
           _g_dbus_debug_print_unlock ();
@@ -714,7 +849,9 @@ _g_dbus_worker_do_read_cb (GInputStream  *input_stream,
       goto out;
     }
 
-  read_message_print_transport_debug (bytes_read, worker);
+  /* [KDBUS] don't print transport dbus debug for kdbus connection */
+  if (!G_IS_KDBUS_CONNECTION (worker->stream))
+    read_message_print_transport_debug (bytes_read, worker);
 
   worker->read_buffer_cur_size += bytes_read;
   if (worker->read_buffer_bytes_wanted == worker->read_buffer_cur_size)
@@ -746,25 +883,61 @@ _g_dbus_worker_do_read_cb (GInputStream  *input_stream,
 
           /* TODO: use connection->priv->auth to decode the message */
 
-          message = g_dbus_message_new_from_blob ((guchar *) worker->read_buffer,
-                                                  worker->read_buffer_cur_size,
-                                                  worker->capabilities,
-                                                  &error);
-          if (message == NULL)
+          if (FALSE)
             {
-              gchar *s;
-              s = _g_dbus_hexdump (worker->read_buffer, worker->read_buffer_cur_size, 2);
-              g_warning ("Error decoding D-Bus message of %" G_GSIZE_FORMAT " bytes\n"
-                         "The error is: %s\n"
-                         "The payload is as follows:\n"
-                         "%s\n",
-                         worker->read_buffer_cur_size,
-                         error->message,
-                         s);
-              g_free (s);
-              _g_dbus_worker_emit_disconnected (worker, FALSE, error);
-              g_error_free (error);
-              goto out;
+            }
+#if defined (G_OS_UNIX) && (KDBUS_TRANSPORT)
+          else if (G_IS_KDBUS_CONNECTION (worker->stream))
+            {
+              GDBusMessageType message_type;
+              gchar *sender;
+              gchar *destination;
+
+              message = _g_dbus_message_new_from_kdbus_items (worker->read_kdbus_msg_items,
+                                                              &error);
+
+              /* [KDBUS] override informations from the user header with kernel msg header */
+              sender = _g_kdbus_get_last_msg_sender (worker->kdbus);
+              g_dbus_message_set_sender (message, sender);
+
+              message_type = g_dbus_message_get_message_type (message);
+              if (message_type == G_DBUS_MESSAGE_TYPE_SIGNAL)
+                {
+                  destination = _g_kdbus_get_last_msg_destination (worker->kdbus);
+                  g_dbus_message_set_destination (message, destination);
+                }
+
+              if (message == NULL)
+                {
+                   g_warning ("Error decoding D-Bus (kdbus) message\n");
+                   g_error_free (error);
+                   goto out;
+                }
+            }
+#endif
+          else
+            {
+              message = g_dbus_message_new_from_blob ((guchar *) worker->read_buffer,
+                                                      worker->read_buffer_cur_size,
+                                                      worker->capabilities,
+                                                      &error);
+
+              if (message == NULL)
+                {
+                  gchar *s;
+                  s = _g_dbus_hexdump (worker->read_buffer, worker->read_buffer_cur_size, 2);
+                  g_warning ("Error decoding D-Bus message of %" G_GSIZE_FORMAT " bytes\n"
+                             "The error is: %s\n"
+                             "The payload is as follows:\n"
+                             "%s\n",
+                             worker->read_buffer_cur_size,
+                             error->message,
+                             s);
+                  g_free (s);
+                  _g_dbus_worker_emit_disconnected (worker, FALSE, error);
+                  g_error_free (error);
+                  goto out;
+                }
             }
 
 #ifdef G_OS_UNIX
@@ -789,7 +962,15 @@ _g_dbus_worker_do_read_cb (GInputStream  *input_stream,
               g_free (s);
               if (G_UNLIKELY (_g_dbus_debug_payload ()))
                 {
-                  s = _g_dbus_hexdump (worker->read_buffer, worker->read_buffer_cur_size, 2);
+                  if (FALSE)
+                    {
+                    }
+#if defined (G_OS_UNIX) && (KDBUS_TRANSPORT)
+                  else if (G_IS_KDBUS_CONNECTION (worker->stream))
+                    s = _g_kdbus_hexdump_all_items (worker->read_kdbus_msg_items);
+#endif
+                  else
+                    s = _g_dbus_hexdump (worker->read_buffer, worker->read_buffer_cur_size, 2);
                   g_print ("%s\n", s);
                   g_free (s);
                 }
@@ -812,6 +993,20 @@ _g_dbus_worker_do_read_cb (GInputStream  *input_stream,
     }
 
  out:
+
+#if defined (G_OS_UNIX) && (KDBUS_TRANSPORT)
+  /* [KDBUS] release memory occupied by kdbus message */
+  if (G_IS_KDBUS_CONNECTION (worker->stream))
+    {
+      if (!_g_kdbus_is_closed (worker->kdbus))
+        {
+          _g_kdbus_release_kmsg (worker->kdbus);
+          worker->read_kdbus_msg_items = NULL;
+        }
+      worker->read_buffer = NULL;
+    }
+#endif
+
   g_mutex_unlock (&worker->read_lock);
 
   /* gives up the reference acquired when calling g_input_stream_read_async() */
@@ -826,6 +1021,24 @@ _g_dbus_worker_do_read_unlocked (GDBusWorker *worker)
    * true, because only failing a read causes us to signal 'closed'.
    */
 
+  /* [KDBUS]
+   * For KDBUS transport we don't  have to alloc buffer (worker->read_buffer)
+   * instead of it we use kdbus memory pool. On connection stage KDBUS client
+   * have to register a memory pool, large enough to  carry all backlog of
+   * data enqueued for the connection.
+   */
+
+#if defined (G_OS_UNIX) && (KDBUS_TRANSPORT)
+  if (G_IS_KDBUS_CONNECTION (worker->stream))
+    {
+      _g_kdbus_read(worker->kdbus,
+                    worker->cancellable,
+                    (GAsyncReadyCallback) _g_dbus_worker_do_read_cb,
+                    _g_dbus_worker_ref (worker));
+      return;
+    }
+#endif
+
   /* if bytes_wanted is zero, it means start reading a message */
   if (worker->read_buffer_bytes_wanted == 0)
     {
@@ -980,22 +1193,41 @@ static void
 write_message_continue_writing (MessageToWriteData *data)
 {
   GOutputStream *ostream;
+
 #ifdef G_OS_UNIX
   GSimpleAsyncResult *simple;
   GUnixFDList *fd_list;
-#endif
 
-#ifdef G_OS_UNIX
   /* Note: we can't access data->simple after calling g_async_result_complete () because the
    * callback can free @data and we're not completing in idle. So use a copy of the pointer.
    */
   simple = data->simple;
-#endif
 
-  ostream = g_io_stream_get_output_stream (data->worker->stream);
-#ifdef G_OS_UNIX
   fd_list = g_dbus_message_get_unix_fd_list (data->message);
-#endif
+
+#ifdef KDBUS_TRANSPORT
+  if (G_IS_KDBUS_CONNECTION (data->worker->stream))
+    {
+      GError *error;
+      error = NULL;
+      data->total_written = _g_kdbus_send (data->worker,
+                                           data->worker->kdbus,
+                                           data->message,
+                                           data->blob,
+                                           data->blob_size,
+                                           fd_list,
+                                           data->worker->cancellable,
+                                           &error);
+
+      g_simple_async_result_complete (simple);
+      g_object_unref (simple);
+      goto out;
+    }
+#endif /* KDBUS_TRANSPORT */
+
+#endif /* G_OS_UNIX */
+
+  ostream = g_io_stream_get_output_stream (data->worker->stream);
 
   g_assert (!g_output_stream_has_pending (ostream));
   g_assert_cmpint (data->total_written, <, data->blob_size);
@@ -1231,11 +1463,33 @@ ostream_flush_cb (GObject      *source_object,
 static void
 start_flush (FlushAsyncData *data)
 {
-  g_output_stream_flush_async (g_io_stream_get_output_stream (data->worker->stream),
-                               G_PRIORITY_DEFAULT,
-                               data->worker->cancellable,
-                               ostream_flush_cb,
-                               data);
+  /*[KDBUS]: TODO: to investigate */
+  if (G_IS_KDBUS_CONNECTION (data->worker->stream))
+    {
+      g_assert (data->flushers != NULL);
+      flush_data_list_complete (data->flushers, NULL);
+      g_list_free (data->flushers);
+
+      g_mutex_lock (&data->worker->write_lock);
+      data->worker->write_num_messages_flushed = data->worker->write_num_messages_written;
+      g_assert (data->worker->output_pending == PENDING_FLUSH);
+      data->worker->output_pending = PENDING_NONE;
+      g_mutex_unlock (&data->worker->write_lock);
+
+      /* OK, cool, finally kick off the next write */
+      continue_writing (data->worker);
+
+      _g_dbus_worker_unref (data->worker);
+      g_free (data);
+    }
+  else
+    {
+      g_output_stream_flush_async (g_io_stream_get_output_stream (data->worker->stream),
+                                   G_PRIORITY_DEFAULT,
+                                   data->worker->cancellable,
+                                   ostream_flush_cb,
+                                   data);
+    }
 }
 
 /* called in private thread shared by all GDBusConnection instances
@@ -1506,6 +1760,22 @@ continue_writing (GDBusWorker *worker)
         {
           /* filters altered the message -> reencode */
           error = NULL;
+
+         /* [KDBUS]
+          * Setting protocol version, before invoking g_dbus_message_to_blob() will
+          * be removed after preparing new function only for kdbus transport purposes
+          * (this function will be able to create blob directly/unconditionally in memfd
+          * object, without making copy), but memfd will be completly reworked soon [1],
+          * so we're still waiting for this:
+          *
+          * [1] https://code.google.com/p/d-bus/source/browse/TODO
+          */
+
+          if (G_IS_KDBUS_CONNECTION (worker->stream))
+            _g_dbus_message_set_protocol_ver (data->message,2);
+          else
+            _g_dbus_message_set_protocol_ver (data->message,1);
+
           new_blob = g_dbus_message_to_blob (data->message,
                                              &new_blob_size,
                                              worker->capabilities,
@@ -1672,6 +1942,11 @@ _g_dbus_worker_new (GIOStream                              *stream,
   if (G_IS_SOCKET_CONNECTION (worker->stream))
     worker->socket = g_socket_connection_get_socket (G_SOCKET_CONNECTION (worker->stream));
 
+#if defined (G_OS_UNIX) && (KDBUS_TRANSPORT)
+  if (G_IS_KDBUS_CONNECTION (worker->stream))
+    worker->kdbus = _g_kdbus_connection_get_kdbus (G_KDBUS_CONNECTION (worker->stream));
+#endif
+
   worker->shared_thread_data = _g_dbus_shared_thread_ref ();
 
   /* begin reading */
diff --git a/gio/gdbusprivate.h b/gio/gdbusprivate.h
index 0e38121..f4ec7e9 100644
--- a/gio/gdbusprivate.h
+++ b/gio/gdbusprivate.h
@@ -79,6 +79,10 @@ void         _g_dbus_worker_close        (GDBusWorker         *worker,
                                           GCancellable        *cancellable,
                                           GSimpleAsyncResult  *result);
 
+/* kdbus transport needs this function to generate local messages */
+void         _g_dbus_worker_queue_or_deliver_received_message    (GDBusWorker   *worker,
+                                                                  GDBusMessage  *message);
+
 /* ---------------------------------------------------------------------------------------------------- */
 
 void _g_dbus_initialize (void);
diff --git a/gio/gkdbus.c b/gio/gkdbus.c
new file mode 100644
index 0000000..0d43fc3
--- /dev/null
+++ b/gio/gkdbus.c
@@ -0,0 +1,2590 @@
+/*  GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2013 Samsung Electronics
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Author: Michal Eljasiewicz   <m.eljasiewic@samsung.com>
+ * Author: Lukasz Skalski       <l.skalski@samsung.com>
+ */
+
+#include "config.h"
+
+#include "gkdbus.h"
+#include "glib-unix.h"
+
+#include <errno.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <stdio.h>
+
+#ifdef HAVE_SYS_FILIO_H
+# include <sys/filio.h>
+#endif
+
+#ifdef HAVE_SYS_UIO_H
+#include <sys/uio.h>
+#endif
+
+#include <glib/gstdio.h>
+#include <gio/gio.h>
+#include <gio/gunixfdlist.h>
+
+#include "glibintl.h"
+#include "gunixfdmessage.h"
+#include "gdbusprivate.h"
+#include "kdbus.h"
+
+
+/**
+ * SECTION:gkdbus
+ * @short_description: Low-level kdbus object
+ * @include: gio/gio.h
+ *
+ * A #GKdbus is a lowlevel adapter for kdbus IPC solution. It is meant
+ * to replace DBUS  as fundamental IPC solution for  Linux, however it
+ * is  still experimental  work in  progress.  You  may  find detailed
+ * description in kdbus.txt at https://github.com/gregkh/kdbus
+ *
+ */
+
+
+/* Size of memory registered with kdbus for receiving messages */
+#define KDBUS_POOL_SIZE (16 * 1024 * 1024)
+
+#define ALIGN8(l) (((l) + 7) & ~7)
+#define ALIGN8_PTR(p) ((void*) ALIGN8((gulong) p))
+
+#define KDBUS_ITEM_HEADER_SIZE G_STRUCT_OFFSET(struct kdbus_item, data)
+#define KDBUS_ITEM_SIZE(s) ALIGN8((s) + KDBUS_ITEM_HEADER_SIZE)
+
+#define KDBUS_ITEM_NEXT(item) \
+        (typeof(item))(((guint8 *)item) + ALIGN8((item)->size))
+
+#define KDBUS_ITEM_FOREACH(item, head, first)                           \
+        for (item = (head)->first;                                      \
+             ((guint8 *)(item) < (guint8 *)(head) + (head)->size) &&    \
+             ((guint8 *)(item) >= (guint8 *)(head));                    \
+             item = KDBUS_ITEM_NEXT(item))
+
+#define g_alloca0(x) memset(g_alloca(x), '\0', (x))
+
+/**
+ * use systemd-bus-drvierd (from systemd) which implements the all
+ * org.freedesktop.DBus methods on kdbus
+ */
+
+#define SYSTEMD_BUS_DRIVERD
+
+
+/* GBusNameOwnerReturnFlags */
+typedef enum
+{
+  G_BUS_REQUEST_NAME_REPLY_PRIMARY_OWNER = 1, /* Caller is now the primary owner of the name, replacing any previous owner */
+  G_BUS_REQUEST_NAME_REPLY_IN_QUEUE = 2,      /* The name already had an owner, the application will be placed in a queue */
+  G_BUS_REQUEST_NAME_REPLY_EXISTS = 3,        /* The name already has an owner */
+  G_BUS_REQUEST_NAME_REPLY_ALREADY_OWNER = 4  /* The application trying to request ownership of a name is already the owner of it */
+} GBusNameOwnerReturnFlags;
+
+
+/* GBusReleaseNameReturnFlags */
+typedef enum
+{
+  G_BUS_RELEASE_NAME_REPLY_RELEASED = 1,     /* The caller has released his claim on the given name */
+  G_BUS_RELEASE_NAME_REPLY_NON_EXISTENT = 2, /* The given name does not exist on this bus*/
+  G_BUS_RELEASE_NAME_REPLY_NOT_OWNER = 3     /* The caller not waiting in the queue to own this name*/
+} GBusReleaseNameReturnFlags;
+
+
+/* GBusStartServiceReturnFlags */
+typedef enum
+{
+  G_BUS_START_REPLY_SUCCESS = 1,             /* The service was successfully started */
+  G_BUS_START_REPLY_ALREADY_RUNNING = 2,     /* A connection already owns the given name */
+} GBusStartServiceReturnFlags;
+
+
+/* GBusCredentialsFlags */
+typedef enum
+{
+  G_BUS_CREDS_PID              = 1,
+  G_BUS_CREDS_UID              = 2,
+  G_BUS_CREDS_UNIQUE_NAME      = 3,
+  G_BUS_CREDS_SELINUX_CONTEXT  = 4
+} GBusCredentialsFlags;
+
+
+static void     g_kdbus_initable_iface_init (GInitableIface  *iface);
+static gboolean g_kdbus_initable_init       (GInitable       *initable,
+                                             GCancellable    *cancellable,
+                                             GError         **error);
+
+#define g_kdbus_get_type _g_kdbus_get_type
+G_DEFINE_TYPE_WITH_CODE (GKdbus, g_kdbus, G_TYPE_OBJECT,
+                         G_IMPLEMENT_INTERFACE (G_TYPE_INITABLE,
+                                                g_kdbus_initable_iface_init));
+
+
+struct _GKdbusPrivate
+{
+  gint               fd;
+  gchar             *path;
+  gchar             *kdbus_buffer;
+  GSList            *kdbus_msg_items;
+  guint64            unique_id;
+  guint64            hello_flags;
+  guint64            attach_flags;
+  guint              closed : 1;
+  guint              inited : 1;
+  guint              timeout;
+  guint              timed_out : 1;
+  guchar             bus_id[16];
+  struct kdbus_msg  *kmsg;
+  GString           *msg_sender;
+  GString           *msg_destination;
+
+  gsize              bloom_size;
+  guint              bloom_n_hash;
+
+  gint              *fds;
+  gint               num_fds;
+
+  gint               memfd;
+};
+
+
+typedef struct {
+  GSource        source;
+  GPollFD        pollfd;
+  GKdbus        *kdbus;
+  GIOCondition   condition;
+  GCancellable  *cancellable;
+  GPollFD        cancel_pollfd;
+  gint64         timeout_time;
+} GKdbusSource;
+
+
+typedef gboolean (*GKdbusSourceFunc) (GKdbus *kdbus,
+                                      GIOCondition condition,
+                                      gpointer user_data);
+
+
+/* Hash keys for bloom filters*/
+const guint8 hash_keys[8][16] =
+{
+  {0xb9,0x66,0x0b,0xf0,0x46,0x70,0x47,0xc1,0x88,0x75,0xc4,0x9c,0x54,0xb9,0xbd,0x15},
+  {0xaa,0xa1,0x54,0xa2,0xe0,0x71,0x4b,0x39,0xbf,0xe1,0xdd,0x2e,0x9f,0xc5,0x4a,0x3b},
+  {0x63,0xfd,0xae,0xbe,0xcd,0x82,0x48,0x12,0xa1,0x6e,0x41,0x26,0xcb,0xfa,0xa0,0xc8},
+  {0x23,0xbe,0x45,0x29,0x32,0xd2,0x46,0x2d,0x82,0x03,0x52,0x28,0xfe,0x37,0x17,0xf5},
+  {0x56,0x3b,0xbf,0xee,0x5a,0x4f,0x43,0x39,0xaf,0xaa,0x94,0x08,0xdf,0xf0,0xfc,0x10},
+  {0x31,0x80,0xc8,0x73,0xc7,0xea,0x46,0xd3,0xaa,0x25,0x75,0x0f,0x9e,0x4c,0x09,0x29},
+  {0x7d,0xf7,0x18,0x4b,0x7b,0xa4,0x44,0xd5,0x85,0x3c,0x06,0xe0,0x65,0x53,0x96,0x6d},
+  {0xf2,0x77,0xe9,0x6f,0x93,0xb5,0x4e,0x71,0x9a,0x0c,0x34,0x88,0x39,0x25,0xbf,0x35}
+};
+
+
+/**
+ * _g_kdbus_get_last_msg_sender
+ *
+ */
+gchar *
+_g_kdbus_get_last_msg_sender (GKdbus  *kdbus)
+{
+  return kdbus->priv->msg_sender->str;
+}
+
+
+/**
+ * _g_kdbus_get_last_msg_destination
+ *
+ */
+gchar *
+_g_kdbus_get_last_msg_destination (GKdbus  *kdbus)
+{
+  return kdbus->priv->msg_destination->str;
+}
+
+
+/**
+ * _g_kdbus_get_last_msg_items:
+ *
+ */
+GSList *
+_g_kdbus_get_last_msg_items (GKdbus  *kdbus)
+{
+  return kdbus->priv->kdbus_msg_items;
+}
+
+
+/**
+ * g_kdbus_add_msg_part:
+ *
+ */
+static void
+g_kdbus_add_msg_part (GKdbus  *kdbus,
+                      gchar   *data,
+                      gsize    size)
+{
+  msg_part* part = g_new (msg_part, 1);
+  part->data = data;
+  part->size = size;
+  kdbus->priv->kdbus_msg_items = g_slist_append(kdbus->priv->kdbus_msg_items, part);
+}
+
+
+/**
+ * _g_kdbus_hexdump_all_items:
+ *
+ */
+gchar *
+_g_kdbus_hexdump_all_items (GSList  *kdbus_msg_items)
+{
+
+  GString *ret;
+  gint item = 1;
+  ret = g_string_new (NULL);
+
+  while (kdbus_msg_items != NULL)
+    {
+      g_string_append_printf (ret, "\n  Item %d\n", item);
+      g_string_append (ret, _g_dbus_hexdump (((msg_part*)kdbus_msg_items->data)->data, ((msg_part*)kdbus_msg_items->data)->size, 2));
+
+      kdbus_msg_items = g_slist_next(kdbus_msg_items);
+      item++;
+    }
+
+  return g_string_free (ret, FALSE);
+}
+
+
+/**
+ * g_kdbus_finalize:
+ *
+ */
+static void
+g_kdbus_finalize (GObject  *object)
+{
+  GKdbus *kdbus = G_KDBUS (object);
+
+  if (kdbus->priv->kdbus_buffer != NULL)
+    munmap (kdbus->priv->kdbus_buffer, KDBUS_POOL_SIZE);
+
+  kdbus->priv->kdbus_buffer = NULL;
+
+  if (kdbus->priv->fd != -1 && !kdbus->priv->closed)
+    _g_kdbus_close (kdbus, NULL);
+
+  g_string_free (kdbus->priv->msg_sender, TRUE);
+  g_string_free (kdbus->priv->msg_destination, TRUE);
+
+  if (G_OBJECT_CLASS (g_kdbus_parent_class)->finalize)
+    (*G_OBJECT_CLASS (g_kdbus_parent_class)->finalize) (object);
+}
+
+
+/**
+ * g_kdbus_class_init:
+ *
+ */
+static void
+g_kdbus_class_init (GKdbusClass  *klass)
+{
+  GObjectClass *gobject_class G_GNUC_UNUSED = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (GKdbusPrivate));
+  gobject_class->finalize = g_kdbus_finalize;
+}
+
+
+/**
+ * g_kdbus_initable_iface_init:
+ *
+ */
+static void
+g_kdbus_initable_iface_init (GInitableIface  *iface)
+{
+  iface->init = g_kdbus_initable_init;
+}
+
+
+/**
+ * g_kdbus_init:
+ *
+ */
+static void
+g_kdbus_init (GKdbus  *kdbus)
+{
+  kdbus->priv = G_TYPE_INSTANCE_GET_PRIVATE (kdbus, G_TYPE_KDBUS, GKdbusPrivate);
+
+  kdbus->priv->fd = -1;
+  kdbus->priv->unique_id = -1;
+  kdbus->priv->memfd = -1;
+
+  kdbus->priv->path = NULL;
+  kdbus->priv->kdbus_buffer = NULL;
+  kdbus->priv->kdbus_msg_items = NULL;
+
+  kdbus->priv->msg_sender = g_string_new (NULL);
+  kdbus->priv->msg_destination = g_string_new (NULL);
+
+  kdbus->priv->fds = NULL;
+  kdbus->priv->num_fds = 0;
+
+  kdbus->priv->hello_flags = KDBUS_HELLO_ACCEPT_FD;
+  kdbus->priv->attach_flags = KDBUS_ATTACH_NAMES;
+}
+
+
+/**
+ * g_kdbus_initable_init:
+ *
+ */
+static gboolean
+g_kdbus_initable_init (GInitable     *initable,
+                       GCancellable  *cancellable,
+                       GError       **error)
+{
+  GKdbus *kdbus;
+
+  g_return_val_if_fail (G_IS_KDBUS (initable), FALSE);
+
+  kdbus = G_KDBUS (initable);
+
+  if (cancellable != NULL)
+    {
+      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                           _("Cancellable initialization not supported"));
+      return FALSE;
+    }
+
+  kdbus->priv->inited = TRUE;
+
+  return TRUE;
+}
+
+
+/**
+ * kdbus_source_prepare:
+ *
+ */
+static gboolean
+kdbus_source_prepare (GSource  *source,
+                      gint     *timeout)
+{
+  GKdbusSource *kdbus_source = (GKdbusSource *)source;
+
+  if (g_cancellable_is_cancelled (kdbus_source->cancellable))
+    return TRUE;
+
+  if (kdbus_source->timeout_time)
+    {
+      gint64 now;
+
+      now = g_source_get_time (source);
+
+      *timeout = (kdbus_source->timeout_time - now + 999) / 1000;
+      if (*timeout < 0)
+        {
+          kdbus_source->kdbus->priv->timed_out = TRUE;
+          *timeout = 0;
+          return TRUE;
+        }
+    }
+  else
+    *timeout = -1;
+
+  if ((kdbus_source->condition & kdbus_source->pollfd.revents) != 0)
+    return TRUE;
+
+  return FALSE;
+}
+
+
+/**
+ * kdbus_source_check:
+ *
+ */
+static gboolean
+kdbus_source_check (GSource  *source)
+{
+  gint timeout;
+
+  return kdbus_source_prepare (source, &timeout);
+}
+
+
+/**
+ * kdbus_source_dispatch
+ *
+ */
+static gboolean
+kdbus_source_dispatch  (GSource      *source,
+                        GSourceFunc   callback,
+                        gpointer      user_data)
+{
+  GKdbusSourceFunc func = (GKdbusSourceFunc)callback;
+  GKdbusSource *kdbus_source = (GKdbusSource *)source;
+  GKdbus *kdbus = kdbus_source->kdbus;
+  gboolean ret;
+
+  if (kdbus_source->kdbus->priv->timed_out)
+    kdbus_source->pollfd.revents |= kdbus_source->condition & (G_IO_IN | G_IO_OUT);
+
+  ret = (*func) (kdbus,
+                 kdbus_source->pollfd.revents & kdbus_source->condition,
+                 user_data);
+
+  if (kdbus->priv->timeout)
+    kdbus_source->timeout_time = g_get_monotonic_time ()
+                               + kdbus->priv->timeout * 1000000;
+
+  else
+    kdbus_source->timeout_time = 0;
+
+  return ret;
+}
+
+
+/**
+ * kdbus_source_finalize
+ *
+ */
+static void
+kdbus_source_finalize (GSource  *source)
+{
+  GKdbusSource *kdbus_source = (GKdbusSource *)source;
+  GKdbus *kdbus;
+
+  kdbus = kdbus_source->kdbus;
+
+  g_object_unref (kdbus);
+
+  if (kdbus_source->cancellable)
+    {
+      g_cancellable_release_fd (kdbus_source->cancellable);
+      g_object_unref (kdbus_source->cancellable);
+    }
+}
+
+
+/**
+ * kdbus_source_closure_callback:
+ *
+ */
+static gboolean
+kdbus_source_closure_callback (GKdbus        *kdbus,
+                               GIOCondition   condition,
+                               gpointer       data)
+{
+  GClosure *closure = data;
+  GValue params[2] = { G_VALUE_INIT, G_VALUE_INIT };
+  GValue result_value = G_VALUE_INIT;
+  gboolean result;
+
+  g_value_init (&result_value, G_TYPE_BOOLEAN);
+
+  g_value_init (&params[0], G_TYPE_KDBUS);
+  g_value_set_object (&params[0], kdbus);
+  g_value_init (&params[1], G_TYPE_IO_CONDITION);
+  g_value_set_flags (&params[1], condition);
+
+  g_closure_invoke (closure, &result_value, 2, params, NULL);
+
+  result = g_value_get_boolean (&result_value);
+  g_value_unset (&result_value);
+  g_value_unset (&params[0]);
+  g_value_unset (&params[1]);
+
+  return result;
+}
+
+
+static GSourceFuncs kdbus_source_funcs =
+{
+  kdbus_source_prepare,
+  kdbus_source_check,
+  kdbus_source_dispatch,
+  kdbus_source_finalize,
+  (GSourceFunc)kdbus_source_closure_callback,
+};
+
+
+/**
+ * kdbus_source_new:
+ *
+ */
+static GSource *
+kdbus_source_new (GKdbus        *kdbus,
+                  GIOCondition   condition,
+                  GCancellable  *cancellable)
+{
+  GSource *source;
+  GKdbusSource *kdbus_source;
+
+  source = g_source_new (&kdbus_source_funcs, sizeof (GKdbusSource));
+  g_source_set_name (source, "GKdbus");
+  kdbus_source = (GKdbusSource *)source;
+
+  kdbus_source->kdbus = g_object_ref (kdbus);
+  kdbus_source->condition = condition;
+
+  if (g_cancellable_make_pollfd (cancellable,
+                                 &kdbus_source->cancel_pollfd))
+    {
+      kdbus_source->cancellable = g_object_ref (cancellable);
+      g_source_add_poll (source, &kdbus_source->cancel_pollfd);
+    }
+
+  kdbus_source->pollfd.fd = kdbus->priv->fd;
+  kdbus_source->pollfd.events = condition;
+  kdbus_source->pollfd.revents = 0;
+  g_source_add_poll (source, &kdbus_source->pollfd);
+
+  if (kdbus->priv->timeout)
+    kdbus_source->timeout_time = g_get_monotonic_time ()
+                               + kdbus->priv->timeout * 1000000;
+  else
+    kdbus_source->timeout_time = 0;
+
+  return source;
+}
+
+
+/**
+ * _g_kdbus_create_source:
+ *
+ */
+GSource *
+_g_kdbus_create_source (GKdbus        *kdbus,
+                        GIOCondition   condition,
+                        GCancellable  *cancellable)
+{
+  g_return_val_if_fail (G_IS_KDBUS (kdbus) && (cancellable == NULL || G_IS_CANCELLABLE (cancellable)), NULL);
+
+  return kdbus_source_new (kdbus, condition, cancellable);
+}
+
+
+/**
+ * _g_kdbus_open:
+ * @kdbus: a #GKdbus.
+ * @address: path to kdbus bus file.
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Opens file descriptor to kdbus bus control.
+ * It is located in /dev/kdbus/uid-name/bus.
+ *
+ * Returns: TRUE on success.
+ */
+gboolean
+_g_kdbus_open (GKdbus       *kdbus,
+               const gchar  *address,
+               GError      **error)
+{
+  g_return_val_if_fail (G_IS_KDBUS (kdbus), FALSE);
+
+  kdbus->priv->fd = open(address, O_RDWR|O_NOCTTY|O_CLOEXEC);
+
+  if (kdbus->priv->fd<0)
+    {
+      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED, _("Can't open kdbus endpoint"));
+      return FALSE;
+    }
+
+  kdbus->priv->closed = FALSE;
+
+  return TRUE;
+}
+
+
+/**
+ * _g_kdbus_close:
+ * @kdbus: a #GKdbus.
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Closes file descriptor to kdbus bus.
+ * Disconnect a connection. If the connection's message list is empty,
+ * the calls succeeds, closes file descriptor to kdbus bus. Otherwise
+ * FALSE is returned without any further side-effects.
+ *
+ * Returns: TRUE on success.
+ *
+ */
+gboolean
+_g_kdbus_close (GKdbus  *kdbus,
+                GError **error)
+{
+  gint res;
+
+  if (kdbus->priv->closed)
+    return TRUE; /* Multiple close not an error */
+
+  g_return_val_if_fail (G_IS_KDBUS (kdbus), FALSE);
+
+  if (ioctl(kdbus->priv->fd, KDBUS_CMD_BYEBYE) < 0)
+    return FALSE;
+
+  while (1)
+    {
+      res = close (kdbus->priv->fd);
+
+      if (res == -1)
+        {
+          if (errno == EINTR)
+            continue;
+
+          g_set_error (error, G_IO_ERROR,
+                       g_io_error_from_errno (errno),
+                       _("Error closing kdbus fd: %s"),
+                       g_strerror (errno));
+          return FALSE;
+        }
+      break;
+    }
+
+  kdbus->priv->closed = TRUE;
+  kdbus->priv->fd = -1;
+
+  return TRUE;
+}
+
+
+/**
+ * _g_kdbus_is_closed:
+ * @kdbus: a #GKdbus.
+ *
+ * checks whether a kdbus is closed.
+ *
+ */
+gboolean
+_g_kdbus_is_closed (GKdbus  *kdbus)
+{
+  g_return_val_if_fail (G_IS_KDBUS (kdbus), FALSE);
+
+  return kdbus->priv->closed;
+}
+
+
+/**
+ * g_kdbus_generate_local_reply:
+ *
+ */
+static GDBusMessage *
+g_kdbus_generate_local_reply (GDBusMessage       *message,
+                              GDBusMessageType    message_type,
+                              GDBusMessageFlags   message_flags,
+                              guint32             message_reply_serial,
+                              GVariant           *message_body,
+                              const gchar        *error_name)
+{
+  GDBusMessage *reply;
+
+  reply = g_dbus_message_new ();
+
+  g_dbus_message_set_sender (reply, "org.freedesktop.DBus");
+  g_dbus_message_set_message_type (reply, message_type);
+  g_dbus_message_set_flags (reply, message_flags);
+  g_dbus_message_set_reply_serial (reply, message_reply_serial);
+
+  g_dbus_message_set_body (reply, message_body);
+
+  if (message != NULL)
+    g_dbus_message_set_destination (reply, g_dbus_message_get_sender (message));
+
+  if (message_type == G_DBUS_MESSAGE_TYPE_ERROR)
+    g_dbus_message_set_error_name (reply, error_name);
+
+  if (G_UNLIKELY (_g_dbus_debug_message ()))
+    {
+      gchar *s;
+      _g_dbus_debug_print_lock ();
+      g_print ("========================================================================\n"
+               "GDBus-debug:Message:\n"
+               "  <<<< RECEIVED LOCAL D-Bus message (N/A bytes)\n");
+
+      s = g_dbus_message_print (reply, 2);
+      g_print ("%s", s);
+      g_free (s);
+      _g_dbus_debug_print_unlock ();
+    }
+
+  return reply;
+}
+
+
+/**
+ * g_kdbus_generate_local_error:
+ *
+ */
+static void
+g_kdbus_generate_local_error (GDBusWorker   *worker,
+                              GDBusMessage  *dbus_msg,
+                              GVariant      *message_body,
+                              gint           error_code)
+{
+  GDBusMessage *reply;
+  GError *error = NULL;
+  gchar *dbus_error_name;
+
+  error = g_error_new_literal (G_DBUS_ERROR, error_code, "");
+  dbus_error_name = g_dbus_error_encode_gerror (error);
+
+  reply = g_kdbus_generate_local_reply (dbus_msg,
+                                        G_DBUS_MESSAGE_TYPE_ERROR,
+                                        G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED,
+                                        g_dbus_message_get_serial (dbus_msg),
+                                        message_body,
+                                        dbus_error_name);
+  _g_dbus_worker_queue_or_deliver_received_message (worker, reply);
+}
+
+
+/**
+ * g_kdbus_check_signature:
+ * Returns: TRUE on success.
+ */
+static gboolean
+g_kdbus_check_signature (GDBusWorker         *worker,
+                         GDBusMessage        *dbus_msg,
+                         const gchar         *method_name,
+                         GVariant            *body,
+                         const GVariantType  *type)
+{
+
+  if (!g_variant_is_of_type (body, type))
+    {
+      GString *error_name = g_string_new (NULL);
+      g_string_printf (error_name, "Call to %s has wrong args (expected %s)", method_name, g_variant_type_peek_string (type));
+      g_kdbus_generate_local_error (worker,
+                                    dbus_msg,
+                                    g_variant_new ("(s)",error_name->str),
+                                    G_DBUS_ERROR_INVALID_ARGS);
+      g_string_free (error_name,TRUE);
+      return FALSE;
+    }
+  else
+    return TRUE;
+}
+
+
+/**
+ * g_kdbus_check_name:
+ * Returns: TRUE on success.
+ */
+static gboolean
+g_kdbus_check_name (GDBusWorker   *worker,
+                    GDBusMessage  *dbus_msg,
+                    const gchar   *name)
+{
+  if (!g_dbus_is_name (name))
+    {
+      GString *error_name = g_string_new (NULL);
+      g_string_printf (error_name, "Name \"%s\" is not valid", name);
+      g_kdbus_generate_local_error (worker,
+                                    dbus_msg,
+                                    g_variant_new ("(s)",error_name->str),
+                                    G_DBUS_ERROR_INVALID_ARGS);
+      g_string_free (error_name,TRUE);
+      return FALSE;
+    }
+  else
+    return TRUE;
+}
+
+
+/**
+ * g_kdbus_translate_request_name_flags:
+ *
+ */
+static void
+g_kdbus_translate_request_name_flags (GBusNameOwnerFlags   flags,
+                                      guint64             *kdbus_flags)
+{
+  guint64 new_flags = 0;
+
+  if (flags & G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT)
+    new_flags |= KDBUS_NAME_ALLOW_REPLACEMENT;
+
+  if (flags & G_BUS_NAME_OWNER_FLAGS_REPLACE)
+    new_flags |= KDBUS_NAME_REPLACE_EXISTING;
+
+  *kdbus_flags = new_flags;
+}
+
+
+/**
+ * g_kdbus_NameHasOwner:
+ * Returns: TRUE on success.
+ */
+static gboolean
+g_kdbus_NameHasOwner (GKdbus *kdbus, const gchar *name)
+{
+  struct kdbus_cmd_conn_info *cmd;
+  gssize size;
+  gint ret;
+
+  if (g_dbus_is_unique_name(name))
+    {
+       size = G_STRUCT_OFFSET (struct kdbus_cmd_conn_info, name);
+       cmd = g_alloca0 (size);
+       cmd->id = g_ascii_strtoull (name+3,NULL,10);
+    }
+  else
+    {
+       size = G_STRUCT_OFFSET (struct kdbus_cmd_conn_info, name) + strlen(name) + 1;
+       cmd = g_alloca0 (size);
+       strcpy(cmd->name, name);
+    }
+
+  cmd->flags = KDBUS_ATTACH_NAMES;
+  cmd->size = size;
+
+  ret = ioctl(kdbus->priv->fd, KDBUS_CMD_CONN_INFO, cmd);
+
+  if (ret<0)
+    return FALSE;
+  else
+    return TRUE;
+}
+
+
+/**
+ * g_kdbus_take_fd:
+ *
+ */
+static void
+g_kdbus_take_fd (GKdbus  *kdbus)
+{
+  struct kdbus_cmd_hello *hello;
+  struct kdbus_item *item;
+  gchar *conn_name;
+  size_t size, conn_name_size;
+
+  conn_name = "gdbus-kdbus";
+  conn_name_size = strlen (conn_name);
+
+  size = ALIGN8(G_STRUCT_OFFSET(struct kdbus_cmd_hello, items)) +
+         ALIGN8(G_STRUCT_OFFSET(struct kdbus_item, str) + conn_name_size + 1);
+
+  hello = g_alloca0(size);
+  hello->conn_flags = kdbus->priv->hello_flags;
+  hello->attach_flags =  kdbus->priv->attach_flags;
+  hello->size = size;
+  hello->pool_size = KDBUS_POOL_SIZE;
+
+  /* connection's human-readable name (only for debugging purposes)*/
+  item = hello->items;
+  item->size = G_STRUCT_OFFSET(struct kdbus_item, str) + conn_name_size + 1;
+  item->type = KDBUS_ITEM_CONN_NAME;
+  memcpy(item->str, conn_name, conn_name_size+1);
+  item = KDBUS_ITEM_NEXT(item);
+
+  if (ioctl(kdbus->priv->fd, KDBUS_CMD_HELLO, hello))
+    g_error("[KDBUS] fd=%d failed to send hello: %m, %d", kdbus->priv->fd,errno);
+
+  kdbus->priv->kdbus_buffer = mmap(NULL, KDBUS_POOL_SIZE, PROT_READ, MAP_SHARED, kdbus->priv->fd, 0);
+
+  if (kdbus->priv->kdbus_buffer == MAP_FAILED)
+    g_error("[KDBUS] error when mmap: %m, %d", errno);
+
+  if (hello->bus_flags > 0xFFFFFFFFULL || hello->conn_flags > 0xFFFFFFFFULL)
+    g_error("[KDBUS] incompatible flags");
+
+  /* read bloom filters parameters */
+  kdbus->priv->bloom_size = (gsize) hello->bloom.size;
+  kdbus->priv->bloom_n_hash = (guint) hello->bloom.n_hash;
+
+  /* validate bloom filters parameters here? */
+
+  kdbus->priv->unique_id = hello->id;
+  memcpy (kdbus->priv->bus_id, hello->id128, 16);
+}
+
+
+/**
+ * g_kdbus_Hello_reply:
+ * Returns: TRUE on success.
+ */
+static gboolean
+g_kdbus_Hello_reply (GDBusWorker   *worker,
+                     GKdbus        *kdbus,
+                     GDBusMessage  *dbus_msg)
+{
+  GString *unique_name;
+  GDBusMessage *reply;
+
+  unique_name = g_string_new(NULL);
+  g_string_printf (unique_name,":1.%" G_GUINT64_FORMAT, kdbus->priv->unique_id);
+
+  reply = g_kdbus_generate_local_reply (dbus_msg,
+                                        G_DBUS_MESSAGE_TYPE_METHOD_RETURN,
+                                        G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED,
+                                        g_dbus_message_get_serial (dbus_msg),
+                                        g_variant_new ("(s)",unique_name->str),
+                                        NULL);
+  _g_dbus_worker_queue_or_deliver_received_message (worker, reply);
+
+  g_string_free (unique_name,TRUE);
+  return TRUE;
+}
+
+
+/**
+ * g_kdbus_RequestName_handler:
+ * Returns: TRUE on success.
+ */
+static gboolean
+g_kdbus_RequestName_handler (GDBusWorker   *worker,
+                             GKdbus        *kdbus,
+                             GDBusMessage  *dbus_msg)
+{
+  GDBusMessage *reply;
+  GBusNameOwnerFlags flags;
+  struct kdbus_cmd_name *kdbus_name;
+  const gchar *name;
+  guint64 kdbus_flags;
+  guint64 size;
+  gint ret;
+  gint status = G_BUS_REQUEST_NAME_REPLY_PRIMARY_OWNER;
+
+  /* read and validate message */
+  GVariant *body = g_dbus_message_get_body (dbus_msg);
+
+  if (!g_kdbus_check_signature (worker, dbus_msg, "RequestName", body, G_VARIANT_TYPE("(su)")))
+    return TRUE;
+
+  g_variant_get (body, "(&su)", &name, &flags);
+
+  if (!g_kdbus_check_name (worker, dbus_msg, name))
+    return TRUE;
+
+  if (*name == ':')
+    {
+      GString *error_name = g_string_new (NULL);
+      g_string_printf (error_name, "Cannot acquire a service starting with ':' such as \"%s\"", name);
+      g_kdbus_generate_local_error (worker,
+                                    dbus_msg,
+                                    g_variant_new ("(s)",error_name->str),
+                                    G_DBUS_ERROR_INVALID_ARGS);
+      g_string_free (error_name,TRUE);
+      return TRUE;
+    }
+
+  g_kdbus_translate_request_name_flags (flags, &kdbus_flags);
+
+  /* calculate size */
+  size = sizeof(*kdbus_name) + strlen(name) + 1;
+  kdbus_name = g_alloca(size);
+
+  /* set message header */
+  memset(kdbus_name, 0, size);
+  strcpy(kdbus_name->name, name);
+  kdbus_name->size = size;
+  kdbus_name->flags = kdbus_flags;
+
+  /* send message */
+  ret = ioctl(kdbus->priv->fd, KDBUS_CMD_NAME_ACQUIRE, kdbus_name);
+  if (ret < 0)
+    {
+      if (errno == EEXIST)
+        status = G_BUS_REQUEST_NAME_REPLY_EXISTS;
+      else if (errno == EALREADY)
+        status = G_BUS_REQUEST_NAME_REPLY_ALREADY_OWNER;
+      else
+        return FALSE;
+    }
+
+  if (kdbus_name->flags & KDBUS_NAME_IN_QUEUE)
+    status = G_BUS_REQUEST_NAME_REPLY_IN_QUEUE;
+
+  /* generate local reply */
+  reply = g_kdbus_generate_local_reply (dbus_msg,
+                                        G_DBUS_MESSAGE_TYPE_METHOD_RETURN,
+                                        G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED,
+                                        g_dbus_message_get_serial (dbus_msg),
+                                        g_variant_new ("(u)",status),
+                                        NULL);
+  _g_dbus_worker_queue_or_deliver_received_message (worker, reply);
+
+  return TRUE;
+}
+
+
+/**
+ * g_kdbus_ReleaseName_handler:
+ * Returns: TRUE on success.
+ */
+static gboolean
+g_kdbus_ReleaseName_handler (GDBusWorker   *worker,
+                             GKdbus        *kdbus,
+                             GDBusMessage  *dbus_msg)
+{
+  GDBusMessage *reply;
+  struct kdbus_cmd_name *kdbus_name;
+  const gchar *name;
+  guint64 size;
+  gint ret;
+  gint status = G_BUS_RELEASE_NAME_REPLY_RELEASED;
+
+  /* read and validate message */
+  GVariant *body = g_dbus_message_get_body (dbus_msg);
+
+  if (!g_kdbus_check_signature (worker, dbus_msg, "ReleaseName", body, G_VARIANT_TYPE("(s)")))
+    return TRUE;
+
+  g_variant_get (body, "(&s)", &name);
+
+  if (!g_kdbus_check_name (worker, dbus_msg, name))
+    return TRUE;
+
+  if (*name == ':')
+    {
+      GString *error_name = g_string_new (NULL);
+      g_string_printf (error_name, "Cannot release a service starting with ':' such as \"%s\"", name);
+      g_kdbus_generate_local_error (worker,
+                                    dbus_msg,
+                                    g_variant_new ("(s)",error_name->str),
+                                    G_DBUS_ERROR_INVALID_ARGS);
+      g_string_free (error_name,TRUE);
+      return TRUE;
+    }
+
+  /* calculate size */
+  size = sizeof(*kdbus_name) + strlen(name) + 1;
+  kdbus_name = g_alloca(size);
+
+  /* set message header */
+  memset(kdbus_name, 0, size);
+  strcpy(kdbus_name->name, name);
+  kdbus_name->size = size;
+
+  /* send message */
+  ret = ioctl(kdbus->priv->fd, KDBUS_CMD_NAME_RELEASE, kdbus_name);
+  if (ret < 0)
+    {
+      if (errno == ESRCH)
+        status = G_BUS_RELEASE_NAME_REPLY_NON_EXISTENT;
+      else if (errno == EADDRINUSE)
+        status = G_BUS_RELEASE_NAME_REPLY_NOT_OWNER;
+      else
+        return FALSE;
+    }
+
+  /* generate local reply */
+  reply = g_kdbus_generate_local_reply (dbus_msg,
+                                        G_DBUS_MESSAGE_TYPE_METHOD_RETURN,
+                                        G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED,
+                                        g_dbus_message_get_serial (dbus_msg),
+                                        g_variant_new ("(u)",status),
+                                        NULL);
+  _g_dbus_worker_queue_or_deliver_received_message (worker, reply);
+
+  return TRUE;
+}
+
+
+/**
+ * g_kdbus_ListNames_handler:
+ * Returns: TRUE on success.
+ */
+static gboolean
+g_kdbus_ListNames_handler (GDBusWorker   *worker,
+                           GKdbus        *kdbus,
+                           GDBusMessage  *dbus_msg,
+                           guint64        flags)
+{
+  GDBusMessage *reply;
+  GVariantBuilder *builder;
+  struct kdbus_cmd_name_list cmd = {};
+  struct kdbus_name_list *name_list;
+  struct kdbus_cmd_name *name;
+  guint64 prev_id = 0;
+  gint ret;
+
+  cmd.flags = flags;
+
+  ret = ioctl(kdbus->priv->fd, KDBUS_CMD_NAME_LIST, &cmd);
+  if (ret < 0)
+    return FALSE;
+
+  /* get name list */
+  name_list = (struct kdbus_name_list *) ((guint8 *) kdbus->priv->kdbus_buffer + cmd.offset);
+
+  builder = g_variant_builder_new (G_VARIANT_TYPE ("as"));
+  KDBUS_ITEM_FOREACH(name, name_list, names)
+    {
+      if ((flags & KDBUS_NAME_LIST_UNIQUE) && name->owner_id != prev_id)
+        {
+          GString *unique_name = g_string_new (NULL);
+
+          g_string_printf (unique_name, ":1.%llu", name->owner_id);
+
+          g_variant_builder_add (builder, "s", unique_name->str);
+          g_string_free (unique_name,TRUE);
+          prev_id = name->owner_id;
+        }
+
+        if (g_dbus_is_name (name->name))
+          g_variant_builder_add (builder, "s", name->name);
+    }
+
+  /* generate local reply */
+  reply = g_kdbus_generate_local_reply (dbus_msg,
+                                        G_DBUS_MESSAGE_TYPE_METHOD_RETURN,
+                                        G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED,
+                                        g_dbus_message_get_serial (dbus_msg),
+                                        g_variant_new ("(as)", builder),
+                                        NULL);
+  _g_dbus_worker_queue_or_deliver_received_message (worker, reply);
+
+  g_variant_builder_unref (builder);
+  ret = ioctl(kdbus->priv->fd, KDBUS_CMD_FREE, &cmd.offset);
+  if (ret < 0)
+    return FALSE;
+
+  return TRUE;
+}
+
+
+/**
+ * g_kdbus_ListQueuedOwners_handler:
+ * Returns: TRUE on success.
+ */
+static gboolean
+g_kdbus_ListQueuedOwners_handler (GDBusWorker   *worker,
+                                  GKdbus        *kdbus,
+                                  GDBusMessage  *dbus_msg)
+{
+  GDBusMessage *reply;
+  GString *unique_name;
+  GVariantBuilder *builder;
+  struct kdbus_cmd_name_list cmd = {};
+  struct kdbus_name_list *name_list;
+  struct kdbus_cmd_name *name;
+  const gchar *service;
+  gint ret;
+
+  /* read and validate message */
+  GVariant *body = g_dbus_message_get_body (dbus_msg);
+
+  if (!g_kdbus_check_signature (worker, dbus_msg, "ListQueuedOwners", body, G_VARIANT_TYPE("(s)")))
+    return TRUE;
+
+  g_variant_get (body, "(&s)", &service);
+
+  if (!g_kdbus_check_name (worker, dbus_msg, service))
+    return TRUE;
+
+  if (!g_kdbus_NameHasOwner (kdbus, service))
+    {
+      GString *error_name = g_string_new (NULL);
+      g_string_printf (error_name, "Could not get owners of name \'%s\': no such name", service);
+      g_kdbus_generate_local_error (worker,
+                                    dbus_msg,
+                                    g_variant_new ("(s)",error_name->str),
+                                    G_DBUS_ERROR_NAME_HAS_NO_OWNER);
+      g_string_free (error_name,TRUE);
+      return TRUE;
+    }
+
+  /* get queued name list */
+  cmd.flags = KDBUS_NAME_LIST_QUEUED;
+
+  ret = ioctl(kdbus->priv->fd, KDBUS_CMD_NAME_LIST, &cmd);
+  if (ret < 0)
+    return FALSE;
+
+  name_list = (struct kdbus_name_list *) ((guint8 *) kdbus->priv->kdbus_buffer + cmd.offset);
+
+  unique_name = g_string_new (NULL);
+  builder = g_variant_builder_new (G_VARIANT_TYPE ("as"));
+  KDBUS_ITEM_FOREACH(name, name_list, names)
+    {
+      if (name->size <= sizeof(*name))
+        continue;
+
+      if (strcmp(name->name, service))
+        continue;
+
+      g_string_printf (unique_name, ":1.%llu", name->owner_id);
+      g_variant_builder_add (builder, "s", unique_name);
+
+    }
+
+  /* generate reply */
+  reply = g_kdbus_generate_local_reply (dbus_msg,
+                                        G_DBUS_MESSAGE_TYPE_METHOD_RETURN,
+                                        G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED,
+                                        g_dbus_message_get_serial (dbus_msg),
+                                        g_variant_new ("(as)", builder),
+                                        NULL);
+  _g_dbus_worker_queue_or_deliver_received_message (worker, reply);
+
+  g_variant_builder_unref (builder);
+  g_string_free (unique_name,TRUE);
+
+  ret = ioctl(kdbus->priv->fd, KDBUS_CMD_FREE, &cmd.offset);
+  if (ret < 0)
+    return FALSE;
+
+  return TRUE;
+}
+
+
+/**
+ * g_kdbus_GetOwner_handler:
+ * Returns: TRUE on success.
+ */
+static gboolean
+g_kdbus_GetOwner_handler (GDBusWorker   *worker,
+                          GKdbus        *kdbus,
+                          GDBusMessage  *dbus_msg,
+                          guint64        flag)
+{
+  GVariant *result = NULL;
+  GDBusMessage *reply;
+  struct kdbus_cmd_conn_info *cmd;
+  struct kdbus_conn_info *conn_info;
+  struct kdbus_item *item;
+  const gchar *name;
+  gssize size;
+  gint ret;
+
+  /* read and validate message */
+  GVariant *body = g_dbus_message_get_body (dbus_msg);
+
+  if (!g_kdbus_check_signature (worker, dbus_msg, "GetOwner", body, G_VARIANT_TYPE("(s)")))
+    return TRUE;
+
+  g_variant_get (body, "(&s)", &name);
+
+  if (!g_kdbus_check_name (worker, dbus_msg, name))
+    return TRUE;
+
+  /* setup kmsg for ioctl */
+  if (g_dbus_is_unique_name(name))
+    {
+       size = G_STRUCT_OFFSET (struct kdbus_cmd_conn_info, name);
+       cmd = g_alloca0 (size);
+       cmd->id = g_ascii_strtoull (name+3,NULL,10);
+    }
+  else
+    {
+       size = G_STRUCT_OFFSET (struct kdbus_cmd_conn_info, name) + strlen(name) + 1;
+       cmd = g_alloca0 (size);
+       strcpy(cmd->name, name);
+    }
+
+  cmd->flags = KDBUS_ATTACH_NAMES;
+  cmd->size = size;
+
+  /* get info about connection */
+  ret = ioctl(kdbus->priv->fd, KDBUS_CMD_CONN_INFO, cmd);
+  if (ret < 0)
+    {
+      GString *error_name = g_string_new (NULL);
+      g_string_printf (error_name, "Could not get owners of name \'%s\': no such name", name);
+      g_kdbus_generate_local_error (worker,
+                                    dbus_msg,
+                                    g_variant_new ("(s)",error_name->str),
+                                    G_DBUS_ERROR_NAME_HAS_NO_OWNER);
+      g_string_free (error_name, TRUE);
+      return TRUE;
+    }
+
+  conn_info = (struct kdbus_conn_info *) ((guint8 *) kdbus->priv->kdbus_buffer + cmd->offset);
+
+  if (conn_info->flags & KDBUS_HELLO_ACTIVATOR)
+    return FALSE;
+
+  if (flag == G_BUS_CREDS_UNIQUE_NAME)
+    {
+       GString *unique_name = g_string_new (NULL);
+
+       g_string_printf (unique_name, ":1.%llu", (unsigned long long) conn_info->id);
+
+       result = g_variant_new ("(s)", unique_name);
+       g_string_free (unique_name,TRUE);
+       goto send_reply;
+    }
+
+  /* read creds info */
+  KDBUS_ITEM_FOREACH(item, conn_info, items)
+   {
+
+      switch (item->type)
+        {
+
+          case KDBUS_ITEM_CREDS:
+
+            if (flag == G_BUS_CREDS_PID)
+              {
+                guint pid = item->creds.pid;
+                result = g_variant_new ("(u)", pid);
+                goto send_reply;
+              }
+
+            if (flag == G_BUS_CREDS_UID)
+              {
+                guint uid = item->creds.uid;
+                result = g_variant_new ("(u)", uid);
+                goto send_reply;
+              }
+
+          case KDBUS_ITEM_SECLABEL:
+            if (flag == G_BUS_CREDS_SELINUX_CONTEXT)
+              {
+                gint counter;
+                gchar *label;
+                GVariantBuilder *builder = g_variant_builder_new (G_VARIANT_TYPE ("ay"));
+
+                label = g_strdup (item->str);
+                if (!label)
+                  goto exit;
+
+                for (counter = 0 ; counter < strlen (label) ; counter++)
+                  {
+                    g_variant_builder_add (builder, "y", label);
+                    label++;
+                  }
+
+                result = g_variant_new ("(ay)", builder);
+                g_variant_builder_unref (builder);
+                g_free (label);
+                goto send_reply;
+
+              }
+            break;
+
+          case KDBUS_ITEM_PID_COMM:
+          case KDBUS_ITEM_TID_COMM:
+          case KDBUS_ITEM_EXE:
+          case KDBUS_ITEM_CMDLINE:
+          case KDBUS_ITEM_CGROUP:
+          case KDBUS_ITEM_CAPS:
+          case KDBUS_ITEM_NAME:
+          case KDBUS_ITEM_AUDIT:
+            break;
+
+        }
+   }
+
+send_reply:
+  if (result == NULL)
+    goto exit;
+
+  /* generate local reply */
+  reply = g_kdbus_generate_local_reply (dbus_msg,
+                                        G_DBUS_MESSAGE_TYPE_METHOD_RETURN,
+                                        G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED,
+                                        g_dbus_message_get_serial (dbus_msg),
+                                        result,
+                                        NULL);
+  _g_dbus_worker_queue_or_deliver_received_message (worker, reply);
+
+exit:
+  ioctl(kdbus->priv->fd, KDBUS_CMD_FREE, &cmd->offset);
+  return TRUE;
+
+}
+
+
+/**
+ * g_kdbus_NameHasOwner_handler:
+ * Returns: TRUE on success.
+ */
+static gboolean
+g_kdbus_NameHasOwner_handler (GDBusWorker   *worker,
+                              GKdbus        *kdbus,
+                              GDBusMessage  *dbus_msg)
+{
+  GDBusMessage *reply;
+  GVariant *result = NULL;
+  const gchar *name;
+
+  /* read and validate message */
+  GVariant *body = g_dbus_message_get_body (dbus_msg);
+
+  if (!g_kdbus_check_signature (worker, dbus_msg, "NameHasOwner", body, G_VARIANT_TYPE("(s)")))
+    return TRUE;
+
+  g_variant_get (body, "(&s)", &name);
+
+  if (!g_kdbus_check_name (worker, dbus_msg, name))
+    return TRUE;
+
+  /* check whether name has owner */
+  if (!g_kdbus_NameHasOwner (kdbus, name))
+    result = g_variant_new ("(b)", FALSE);
+  else
+    result = g_variant_new ("(b)", TRUE);
+
+  /* generate local reply */
+  reply = g_kdbus_generate_local_reply (dbus_msg,
+                                        G_DBUS_MESSAGE_TYPE_METHOD_RETURN,
+                                        G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED,
+                                        g_dbus_message_get_serial (dbus_msg),
+                                        result,
+                                        NULL);
+  _g_dbus_worker_queue_or_deliver_received_message (worker, reply);
+  return TRUE;
+}
+
+
+/**
+ * g_kdbus_GetId_handler:
+ * Returns: TRUE on success.
+ */
+static gboolean
+g_kdbus_GetId_handler (GDBusWorker   *worker,
+                       GKdbus        *kdbus,
+                       GDBusMessage  *dbus_msg)
+{
+  GDBusMessage *reply;
+  GString *result = g_string_new (NULL);
+  gint i;
+
+  for (i=0; i<16; i++)
+    g_string_append_printf (result, "%02x", kdbus->priv->bus_id[i]);
+
+  /* generate local reply */
+  reply = g_kdbus_generate_local_reply (dbus_msg,
+                                        G_DBUS_MESSAGE_TYPE_METHOD_RETURN,
+                                        G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED,
+                                        g_dbus_message_get_serial (dbus_msg),
+                                        g_variant_new ("(s)", result->str),
+                                        NULL);
+  _g_dbus_worker_queue_or_deliver_received_message (worker, reply);
+
+  g_string_free (result,TRUE);
+  return TRUE;
+}
+
+
+/**
+ * g_kdbus_StartServiceByName_handler:
+ * Returns: TRUE on success.
+ *
+ */
+static gboolean
+g_kdbus_StartServiceByName_handler (GDBusWorker   *worker,
+                                    GKdbus        *kdbus,
+                                    GDBusMessage  *dbus_msg)
+{
+  GDBusMessage *reply;
+  GVariant *body;
+  const gchar *name;
+  guint64 flags;
+
+  body = g_dbus_message_get_body (dbus_msg);
+
+  if (!g_kdbus_check_signature (worker, dbus_msg, "StartServiceByName", body, G_VARIANT_TYPE("(su)")))
+    return TRUE;
+
+  g_variant_get (body, "(&su)", &name, &flags);
+
+  if (!g_kdbus_check_name (worker, dbus_msg, name))
+    return TRUE;
+
+  if (g_kdbus_NameHasOwner (kdbus, name))
+    {
+      reply = g_kdbus_generate_local_reply (dbus_msg,
+                                            G_DBUS_MESSAGE_TYPE_METHOD_RETURN,
+                                            G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED,
+                                            g_dbus_message_get_serial (dbus_msg),
+                                            g_variant_new ("(u)", G_BUS_START_REPLY_ALREADY_RUNNING),
+                                            NULL);
+      _g_dbus_worker_queue_or_deliver_received_message (worker, reply);
+      return TRUE;
+    }
+
+  /* TODO */
+  g_error ("[KDBUS] StartServiceByName method is not implemented yet");
+
+  return TRUE;
+}
+
+
+/**
+ * g_kdbus_AddMatch_handler:
+ * Returns: TRUE on success.
+ *
+ */
+static gboolean
+g_kdbus_AddMatch_handler (GDBusWorker   *worker,
+                          GKdbus        *kdbus,
+                          GDBusMessage  *dbus_msg)
+{
+  GVariant *body;
+  const gchar *rule;
+
+  body = g_dbus_message_get_body (dbus_msg);
+
+  if (!g_kdbus_check_signature (worker, dbus_msg, "AddMatch", body, G_VARIANT_TYPE("(s)")))
+    return TRUE;
+
+  g_variant_get (body, "(&s)", &rule);
+
+  /* TODO */
+  g_error ("[KDBUS] AddMatch method is not implemented yet");
+
+  return TRUE;
+}
+
+
+/**
+ * g_kdbus_RemoveMatch_handler:
+ * Returns: TRUE on success.
+ *
+ */
+static gboolean
+g_kdbus_RemoveMatch_handler (GDBusWorker   *worker,
+                             GKdbus        *kdbus,
+                             GDBusMessage  *dbus_msg)
+{
+  GVariant *body;
+  const gchar *rule;
+
+  body = g_dbus_message_get_body (dbus_msg);
+
+  if (!g_kdbus_check_signature (worker, dbus_msg, "RemoveMatch", body, G_VARIANT_TYPE("(s)")))
+    return TRUE;
+
+  g_variant_get (body, "(&s)", &rule);
+
+  /* TODO */
+  g_error ("[KDBUS] RemoveMatch method is not implemented yet");
+
+  return TRUE;
+}
+
+
+/**
+ * g_kdbus_UnsupportedMethod_handler:
+ * Returns: TRUE on success.
+ */
+static gboolean
+g_kdbus_UnsupportedMethod_handler (GDBusWorker   *worker,
+                                   GKdbus        *kdbus,
+                                   GDBusMessage  *dbus_msg,
+                                   const gchar   *method_name)
+{
+  GString *error_name = g_string_new (NULL);
+  g_string_printf (error_name, "Method \"%s\" is not supported", method_name);
+  g_kdbus_generate_local_error (worker,
+                                dbus_msg,
+                                g_variant_new ("(s)",error_name->str),
+                                G_DBUS_ERROR_UNKNOWN_METHOD);
+  g_string_free (error_name,TRUE);
+  return TRUE;
+}
+
+
+/**
+ * g_kdbus_bus_driver:
+ *
+ */
+static gboolean
+g_kdbus_bus_driver (GDBusWorker   *worker,
+                    GKdbus        *kdbus,
+                    GDBusMessage  *dbus_msg)
+{
+  gboolean ret = FALSE;
+
+  /* Hello */
+  if (g_strcmp0(g_dbus_message_get_member(dbus_msg), "Hello") == 0)
+    {
+      g_kdbus_take_fd (kdbus);
+      ret = g_kdbus_Hello_reply (worker, kdbus, dbus_msg);
+    }
+
+  /* RequestName and ReleaseName */
+  else if (g_strcmp0(g_dbus_message_get_member(dbus_msg), "RequestName") == 0)
+    ret = g_kdbus_RequestName_handler (worker, kdbus, dbus_msg);
+  else if (g_strcmp0(g_dbus_message_get_member(dbus_msg), "ReleaseName") == 0)
+    ret = g_kdbus_ReleaseName_handler (worker, kdbus, dbus_msg);
+
+  /* All List* Methods */
+  else if (g_strcmp0(g_dbus_message_get_member(dbus_msg), "ListNames") == 0)
+    ret = g_kdbus_ListNames_handler (worker, kdbus, dbus_msg, KDBUS_NAME_LIST_UNIQUE | KDBUS_NAME_LIST_NAMES);
+  else if (g_strcmp0(g_dbus_message_get_member(dbus_msg), "ListActivatableNames") == 0)
+    ret = g_kdbus_ListNames_handler (worker, kdbus, dbus_msg, KDBUS_NAME_LIST_ACTIVATORS);
+  else if (g_strcmp0(g_dbus_message_get_member(dbus_msg), "ListQueuedOwners") == 0)
+    ret = g_kdbus_ListQueuedOwners_handler (worker, kdbus, dbus_msg);
+
+  /* All Get* Methods */
+  else if (g_strcmp0(g_dbus_message_get_member(dbus_msg), "GetNameOwner") == 0)
+    ret = g_kdbus_GetOwner_handler (worker, kdbus, dbus_msg, G_BUS_CREDS_UNIQUE_NAME);
+  else if (g_strcmp0(g_dbus_message_get_member(dbus_msg), "GetConnectionUnixProcessID") == 0)
+    ret = g_kdbus_GetOwner_handler (worker, kdbus, dbus_msg, G_BUS_CREDS_PID);
+  else if (g_strcmp0(g_dbus_message_get_member(dbus_msg), "GetConnectionUnixUser") == 0)
+    ret = g_kdbus_GetOwner_handler (worker, kdbus, dbus_msg, G_BUS_CREDS_UID);
+  else if (g_strcmp0(g_dbus_message_get_member(dbus_msg), "GetConnectionSELinuxSecurityContext") == 0)
+    ret = g_kdbus_GetOwner_handler (worker, kdbus, dbus_msg, G_BUS_CREDS_SELINUX_CONTEXT);
+  else if (g_strcmp0(g_dbus_message_get_member(dbus_msg), "GetId") == 0)
+    ret = g_kdbus_GetId_handler (worker, kdbus, dbus_msg);
+
+  /* NameHasOwner nad StartServiceByName methods */
+  else if (g_strcmp0(g_dbus_message_get_member(dbus_msg), "NameHasOwner") == 0)
+    ret = g_kdbus_NameHasOwner_handler (worker, kdbus, dbus_msg);
+  else if (g_strcmp0(g_dbus_message_get_member(dbus_msg), "StartServiceByName") == 0)
+    ret = g_kdbus_StartServiceByName_handler (worker, kdbus, dbus_msg);
+
+  /* AddMatch and RemoveMatch */
+  else if (g_strcmp0(g_dbus_message_get_member(dbus_msg), "AddMatch") == 0)
+    ret = g_kdbus_AddMatch_handler (worker, kdbus, dbus_msg);
+  else if (g_strcmp0(g_dbus_message_get_member(dbus_msg), "RemoveMatch") == 0)
+    ret = g_kdbus_RemoveMatch_handler (worker, kdbus, dbus_msg);
+
+  /* Unsupported Methods */
+  else if (g_strcmp0(g_dbus_message_get_member(dbus_msg), "ReloadConfig") == 0)
+    ret = g_kdbus_UnsupportedMethod_handler (worker, kdbus, dbus_msg, "ReloadConfig");
+  else if (g_strcmp0(g_dbus_message_get_member(dbus_msg), "UpdateActivationEnvironment") == 0)
+    ret = g_kdbus_UnsupportedMethod_handler (worker, kdbus, dbus_msg, "UpdateActivationEnvironment");
+
+  else
+    {
+      GString *error_name;
+
+      error_name = g_string_new (NULL);
+      g_string_printf (error_name, "org.freedesktop.DBus does not understand message %s", g_dbus_message_get_member(dbus_msg));
+
+      g_kdbus_generate_local_error (worker,
+                                    dbus_msg,
+                                    g_variant_new ("(s)",error_name->str),
+                                    G_DBUS_ERROR_UNKNOWN_METHOD);
+      g_string_free (error_name,TRUE);
+    }
+
+  return ret;
+}
+
+
+/**
+ * g_kdbus_alloc_memfd:
+ *
+ */
+static gboolean
+g_kdbus_alloc_memfd (GKdbus  *kdbus)
+{
+  struct kdbus_cmd_memfd_make *memfd;
+  struct kdbus_item *item;
+  gssize size;
+  gchar *name = "gdbus-memfd";
+
+  size = ALIGN8(G_STRUCT_OFFSET(struct kdbus_cmd_memfd_make, items)) +
+         ALIGN8(G_STRUCT_OFFSET(struct kdbus_item, str)) +
+         strlen(name) + 1;
+
+  memfd = g_alloca0 (size);
+  memfd->size = size;
+
+  item = memfd->items;
+  item->size = ALIGN8(offsetof(struct kdbus_item, str)) + strlen(name) + 1;
+  item->type = KDBUS_ITEM_MEMFD_NAME;
+  memcpy(item->str, name, strlen(name) + 1);
+
+  if (ioctl(kdbus->priv->fd, KDBUS_CMD_MEMFD_NEW, memfd) < 0)
+    return FALSE;
+
+  kdbus->priv->memfd = memfd->fd;
+
+  return TRUE;
+}
+
+
+/**
+ * _g_kdbus_release_msg:
+ * Release memory occupied by kdbus_msg.
+ * Use after DBUS message is extracted.
+ */
+void
+_g_kdbus_release_kmsg (GKdbus  *kdbus)
+{
+  struct kdbus_item *item = NULL;
+  GSList *iterator = NULL;
+  guint64 offset;
+
+  offset = (guint8 *)kdbus->priv->kmsg - (guint8 *)kdbus->priv->kdbus_buffer;
+  ioctl(kdbus->priv->fd, KDBUS_CMD_FREE, &offset);
+
+  for (iterator = kdbus->priv->kdbus_msg_items; iterator; iterator = iterator->next)
+    g_free ((msg_part*)iterator->data);
+
+  g_slist_free (kdbus->priv->kdbus_msg_items);
+  kdbus->priv->kdbus_msg_items = NULL;
+
+  KDBUS_ITEM_FOREACH (item, kdbus->priv->kmsg, items)
+    {
+      if (item->type == KDBUS_ITEM_PAYLOAD_MEMFD)
+        close(item->memfd.fd);
+      else if (item->type == KDBUS_ITEM_FDS)
+        {
+          gint i;
+          gint num_fds = (item->size - G_STRUCT_OFFSET(struct kdbus_item, fds)) / sizeof(int);
+
+          for (i = 0; i < num_fds; i++)
+            close(item->fds[i]);
+        }
+    }
+}
+
+
+/**
+ * g_kdbus_append_payload_vec:
+ *
+ */
+static void
+g_kdbus_append_payload_vec (struct kdbus_item **item,
+                            const void         *data_ptr,
+                            gssize              size)
+{
+  *item = ALIGN8_PTR(*item);
+  (*item)->size = G_STRUCT_OFFSET (struct kdbus_item, vec) + sizeof(struct kdbus_vec);
+  (*item)->type = KDBUS_ITEM_PAYLOAD_VEC;
+  (*item)->vec.address = (guint64)((guintptr)data_ptr);
+  (*item)->vec.size = size;
+  *item = KDBUS_ITEM_NEXT(*item);
+}
+
+
+/**
+ * g_kdbus_append_payload_memfd:
+ *
+ */
+static void
+g_kdbus_append_payload_memfd (struct kdbus_item **item,
+                              int                 fd,
+                              gssize              size)
+{
+  *item = ALIGN8_PTR(*item);
+  (*item)->size = G_STRUCT_OFFSET (struct kdbus_item, memfd) + sizeof(struct kdbus_memfd);
+  (*item)->type = KDBUS_ITEM_PAYLOAD_MEMFD;
+  (*item)->memfd.fd = fd;
+  (*item)->memfd.size = size;
+  *item = KDBUS_ITEM_NEXT(*item);
+}
+
+
+/**
+ * g_kdbus_append_payload_destiantion:
+ *
+ */
+static void
+g_kdbus_append_destination (struct kdbus_item **item,
+                            const gchar        *destination,
+                            gsize               size)
+{
+  *item = ALIGN8_PTR(*item);
+  (*item)->size = G_STRUCT_OFFSET (struct kdbus_item, str) + size + 1;
+  (*item)->type = KDBUS_ITEM_DST_NAME;
+  memcpy ((*item)->str, destination, size+1);
+  *item = KDBUS_ITEM_NEXT(*item);
+}
+
+
+/**
+ * g_kdbus_append_payload_bloom:
+ *
+ */
+static struct kdbus_bloom_filter *
+g_kdbus_append_bloom (struct kdbus_item **item,
+                      gsize               size)
+{
+  struct kdbus_item *bloom_item;
+
+  bloom_item = ALIGN8_PTR(*item);
+  bloom_item->size = G_STRUCT_OFFSET (struct kdbus_item, bloom_filter) +
+                     G_STRUCT_OFFSET (struct kdbus_bloom_filter, data) +
+                     size;
+
+  bloom_item->type = KDBUS_ITEM_BLOOM_FILTER;
+
+  *item = KDBUS_ITEM_NEXT(bloom_item);
+  return &bloom_item->bloom_filter;
+}
+
+
+/**
+ * g_kdbus_append_fds:
+ *
+ */
+static void
+g_kdbus_append_fds (struct kdbus_item **item,
+                    GUnixFDList        *fd_list)
+{
+  *item = ALIGN8_PTR(*item);
+  (*item)->size = G_STRUCT_OFFSET (struct kdbus_item, fds) + sizeof(int) * g_unix_fd_list_get_length(fd_list);
+  (*item)->type = KDBUS_ITEM_FDS;
+  memcpy ((*item)->fds, g_unix_fd_list_peek_fds(fd_list, NULL), sizeof(int) * g_unix_fd_list_get_length(fd_list));
+
+  *item = KDBUS_ITEM_NEXT(*item);
+}
+
+
+/**
+ * _g_kdbus_attach_fds_to_msg:
+ *
+ */
+void
+_g_kdbus_attach_fds_to_msg (GKdbus       *kdbus,
+                            GUnixFDList **fd_list)
+{
+  if ((kdbus->priv->fds != NULL) && (kdbus->priv->num_fds > 0))
+    {
+      gint n;
+
+      if (*fd_list == NULL)
+        *fd_list = g_unix_fd_list_new();
+
+      for (n = 0; n < kdbus->priv->num_fds; n++)
+        {
+          g_unix_fd_list_append (*fd_list, kdbus->priv->fds[n], NULL);
+          (void) g_close (kdbus->priv->fds[n], NULL);
+        }
+
+      g_free (kdbus->priv->fds);
+      kdbus->priv->fds = NULL;
+      kdbus->priv->num_fds = 0;
+    }
+}
+
+
+/**
+ * g_kdbus_bloom_add_data:
+ * Based on bus-bloom.c from systemd
+ * http://cgit.freedesktop.org/systemd/systemd/tree/src/libsystemd/sd-bus/bus-bloom.c
+ */
+static void
+g_kdbus_bloom_add_data (GKdbus      *kdbus,
+                        guint64      bloom_data [],
+                        const void  *data,
+                        gsize        n)
+{
+  guint8 hash[8];
+  guint64 bit_num;
+  guint bytes_num = 0;
+  guint cnt_1, cnt_2;
+
+  guint c = 0;
+  guint64 p = 0;
+
+  bit_num = kdbus->priv->bloom_size * 8;
+
+  if (bit_num > 1)
+    bytes_num = ((__builtin_clzll(bit_num) ^ 63U) + 7) / 8;
+
+  for (cnt_1 = 0; cnt_1 < (kdbus->priv->bloom_n_hash); cnt_1++)
+    {
+      for (cnt_2 = 0; cnt_2 < bytes_num; cnt_2++)
+        {
+          if (c <= 0)
+            {
+              g_siphash24(hash, data, n, hash_keys[cnt_1++]);
+              c += 8;
+            }
+
+          p = (p << 8ULL) | (guint64) hash[8 - c];
+          c--;
+        }
+
+      p &= bit_num - 1;
+      bloom_data[p >> 6] |= 1ULL << (p & 63);
+    }
+}
+
+
+/**
+ * g_kdbus_bloom_add_pair:
+ *
+ */
+static void
+g_kdbus_bloom_add_pair (GKdbus       *kdbus,
+                        guint64       bloom_data [],
+                        const gchar  *parameter,
+                        const gchar  *value)
+{
+  GString *data = g_string_new (NULL);
+
+  g_string_printf (data,"%s:%s",parameter,value);
+  g_kdbus_bloom_add_data(kdbus, bloom_data, data->str, data->len);
+  g_string_free (data, TRUE);
+}
+
+
+/**
+ * g_kdbus_bloom_add_prefixes:
+ *
+ */
+static void
+g_kdbus_bloom_add_prefixes (GKdbus       *kdbus,
+                            guint64       bloom_data [],
+                            const gchar  *parameter,
+                            const gchar  *value,
+                            gchar         separator)
+{
+  GString *data = g_string_new (NULL);
+
+  g_string_printf (data,"%s:%s",parameter,value);
+
+  for (;;)
+    {
+      gchar *last_sep;
+      last_sep = strrchr(data->str, separator);
+      if (!last_sep || last_sep == data->str)
+        break;
+
+      *last_sep = 0;
+      g_kdbus_bloom_add_data(kdbus, bloom_data, data->str, last_sep-(data->str));
+    }
+  g_string_free (data, TRUE);
+}
+
+
+/**
+ * g_kdbus_setup_bloom:
+ * Based on bus-bloom.c from systemd
+ * http://cgit.freedesktop.org/systemd/systemd/tree/src/libsystemd/sd-bus/bus-bloom.c
+ */
+static void
+g_kdbus_setup_bloom (GKdbus                     *kdbus,
+                     GDBusMessage               *dbus_msg,
+                     struct kdbus_bloom_filter  *bloom_filter)
+{
+  GVariant *body;
+  GVariantIter iter;
+  GVariant *child;
+
+  const gchar *message_type;
+  const gchar *interface;
+  const gchar *member;
+  const gchar *path;
+
+  void *bloom_data;
+  gint cnt = 0;
+
+  body = g_dbus_message_get_body (dbus_msg);
+  message_type = _g_dbus_enum_to_string (G_TYPE_DBUS_MESSAGE_TYPE, g_dbus_message_get_message_type (dbus_msg));
+  interface = g_dbus_message_get_interface (dbus_msg);
+  member = g_dbus_message_get_member (dbus_msg);
+  path = g_dbus_message_get_path (dbus_msg);
+
+  bloom_data = bloom_filter->data;
+  memset (bloom_data, 0, kdbus->priv->bloom_size);
+  bloom_filter->generation = 0;
+
+  g_kdbus_bloom_add_pair(kdbus, bloom_data, "message-type", message_type);
+
+  if (interface)
+    g_kdbus_bloom_add_pair(kdbus, bloom_data, "interface", interface);
+
+  if (member)
+    g_kdbus_bloom_add_pair(kdbus, bloom_data, "member", member);
+
+  if (path)
+    {
+      g_kdbus_bloom_add_pair(kdbus, bloom_data, "path", path);
+      g_kdbus_bloom_add_pair(kdbus, bloom_data, "path-slash-prefix", path);
+      g_kdbus_bloom_add_prefixes(kdbus, bloom_data, "path-slash-prefix", path, '/');
+    }
+
+  if (body != NULL)
+    {
+      g_variant_iter_init (&iter, body);
+      while ((child = g_variant_iter_next_value (&iter)))
+        {
+          gchar buf[sizeof("arg")-1 + 2 + sizeof("-slash-prefix")];
+          gchar *child_string;
+          gchar *e;
+
+          /* Is it necessary? */
+          //if (g_variant_is_container (child))
+          //  iterate_container_recursive (child);
+
+          if (!(g_variant_is_of_type (child, G_VARIANT_TYPE_STRING)) &&
+              !(g_variant_is_of_type (child, G_VARIANT_TYPE_OBJECT_PATH)) &&
+              !(g_variant_is_of_type (child, G_VARIANT_TYPE_SIGNATURE)))
+            break;
+
+          child_string = g_variant_dup_string (child, NULL);
+
+          e = stpcpy(buf, "arg");
+          if (cnt < 10)
+            *(e++) = '0' + (char) cnt;
+          else
+            {
+              *(e++) = '0' + (char) (cnt / 10);
+              *(e++) = '0' + (char) (cnt % 10);
+            }
+
+          *e = 0;
+          g_kdbus_bloom_add_pair(kdbus, bloom_data, buf, child_string);
+
+          strcpy(e, "-dot-prefix");
+          g_kdbus_bloom_add_prefixes(kdbus, bloom_data, buf, child_string, '.');
+
+          strcpy(e, "-slash-prefix");
+          g_kdbus_bloom_add_prefixes(kdbus, bloom_data, buf, child_string, '/');
+
+          g_free (child_string);
+          g_variant_unref (child);
+          cnt++;
+        }
+    }
+}
+
+
+/**
+ * g_kdbus_NameOwnerChanged_generate:
+ * TODO: Not tesed yet
+ */
+static gssize
+g_kdbus_NameOwnerChanged_generate (GKdbus             *kdbus,
+                                   struct kdbus_item  *item)
+{
+  GVariant *result = NULL;
+  GDBusMessage *reply;
+  GError *error;
+  guchar *blob;
+  gssize reply_size = 0;
+
+  gchar *owner;
+  gchar *old_owner;
+  gchar *new_owner;
+
+  /* ID change */
+  if (item->type == KDBUS_ITEM_ID_ADD || item->type == KDBUS_ITEM_ID_REMOVE)
+    {
+      owner = "";
+
+      if (item->type == KDBUS_ITEM_ID_ADD)
+        {
+          old_owner = NULL;
+          new_owner = owner;
+        }
+      else
+        {
+          old_owner = owner;
+          new_owner = NULL;
+        }
+    }
+
+  /* name change */
+  if (item->type == KDBUS_ITEM_NAME_ADD ||
+      item->type == KDBUS_ITEM_NAME_REMOVE ||
+      item->type == KDBUS_ITEM_NAME_CHANGE )
+    {
+     g_error ("[KDBUS] 'NameChange' is not implemented yet");
+    }
+
+  result = g_variant_new ("(sss)", owner, old_owner, new_owner);
+  reply = g_kdbus_generate_local_reply (NULL,
+                                        G_DBUS_MESSAGE_TYPE_SIGNAL,
+                                        G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED,
+                                        -1,
+                                        result,
+                                        NULL);
+
+  _g_dbus_message_set_protocol_ver (reply,2);
+  blob =  g_dbus_message_to_blob (reply, (gsize*) &reply_size, 0, &error);
+  if (blob == NULL)
+
+    g_error ("[KDBUS] NameOwnerChanged: %s\n",error->message);
+
+  ((guint32 *) blob)[2] = GUINT32_TO_LE (-1);
+  g_kdbus_add_msg_part (kdbus, (gchar*)blob, reply_size);
+
+  return reply_size;
+
+}
+
+
+/**
+ * g_kdbus_KernelMethodError_generate:
+ *
+ */
+static gssize
+g_kdbus_KernelMethodError_generate (GKdbus             *kdbus,
+                                    struct kdbus_item  *item)
+{
+  GVariant *error_name;
+  GDBusMessage *reply;
+  GError *error;
+  guchar *blob;
+  gssize reply_size = 0;
+
+  if (item->type == KDBUS_ITEM_REPLY_TIMEOUT)
+    error_name = g_variant_new ("(s)", "Method call timed out");
+  else
+    error_name = g_variant_new ("(s)", "Method call peer died");
+
+  error = NULL;
+  reply = g_kdbus_generate_local_reply (NULL,
+                                        G_DBUS_MESSAGE_TYPE_ERROR,
+                                        G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED,
+                                        -1,
+                                        error_name,
+                                        "org.freedesktop.DBus.Error.NoReply");
+
+  _g_dbus_message_set_protocol_ver (reply,2);
+  blob =  g_dbus_message_to_blob (reply, (gsize*) &reply_size, 0, &error);
+
+  if (blob == NULL)
+    g_error ("[KDBUS] KernelMethodError: %s\n",error->message);
+
+  ((guint32 *) blob)[2] = GUINT32_TO_LE (-1);
+  g_kdbus_add_msg_part (kdbus, (gchar*)blob, reply_size);
+
+  return reply_size;
+}
+
+
+/**
+ * g_kdbus_decode_kernel_msg:
+ *
+ */
+static gssize
+g_kdbus_decode_kernel_msg (GKdbus  *kdbus)
+{
+  struct kdbus_item *item = NULL;
+  gssize size = 0;
+
+  KDBUS_ITEM_FOREACH(item, kdbus->priv->kmsg, items)
+    {
+      switch (item->type)
+        {
+          case KDBUS_ITEM_ID_ADD:
+          case KDBUS_ITEM_ID_REMOVE:
+          case KDBUS_ITEM_NAME_ADD:
+          case KDBUS_ITEM_NAME_REMOVE:
+          case KDBUS_ITEM_NAME_CHANGE:
+            size = g_kdbus_NameOwnerChanged_generate (kdbus, item);
+            break;
+
+          case KDBUS_ITEM_REPLY_TIMEOUT:
+          case KDBUS_ITEM_REPLY_DEAD:
+            size = g_kdbus_KernelMethodError_generate (kdbus, item);
+            break;
+
+          default:
+            g_error ("[KDBUS] KERNEL: Unknown filed - %lld", item->type);
+        }
+    }
+
+  /* Override information from the user header with data from the kernel */
+  g_string_printf (kdbus->priv->msg_sender, "org.freedesktop.DBus");
+
+  /* for destination */
+  if (kdbus->priv->kmsg->dst_id == KDBUS_DST_ID_BROADCAST)
+    /* for broadcast messages we don't have to set destination */
+    ;
+  else if (kdbus->priv->kmsg->dst_id == KDBUS_DST_ID_NAME)
+    g_string_printf (kdbus->priv->msg_destination, ":1.%" G_GUINT64_FORMAT, (guint64) kdbus->priv->unique_id);
+  else
+    g_string_printf (kdbus->priv->msg_destination, ":1.%" G_GUINT64_FORMAT, (guint64) kdbus->priv->kmsg->dst_id);
+
+
+  return size;
+}
+
+
+/**
+ * g_kdbus_decode_dbus_msg:
+ *
+ */
+static gssize
+g_kdbus_decode_dbus_msg (GKdbus  *kdbus)
+{
+  struct kdbus_item *item;
+  gchar *msg_ptr;
+  gssize ret_size = 0;
+  gssize data_size = 0;
+  const gchar *destination = NULL;
+
+  KDBUS_ITEM_FOREACH(item, kdbus->priv->kmsg, items)
+    {
+      if (item->size <= KDBUS_ITEM_HEADER_SIZE)
+        g_error("[KDBUS] %llu bytes - invalid data record\n", item->size);
+
+      data_size = item->size - KDBUS_ITEM_HEADER_SIZE;
+
+      switch (item->type)
+        {
+
+         /* KDBUS_ITEM_DST_NAME */
+         case KDBUS_ITEM_DST_NAME:
+           destination = item->str;
+           break;
+
+        /* KDBUS_ITEM_PALOAD_OFF */
+        case KDBUS_ITEM_PAYLOAD_OFF:
+
+          msg_ptr = (gchar*) kdbus->priv->kmsg + item->vec.offset;
+          g_kdbus_add_msg_part (kdbus, msg_ptr, item->vec.size);
+          ret_size += item->vec.size;
+
+          break;
+
+        /* KDBUS_ITEM_PAYLOAD_MEMFD */
+        case KDBUS_ITEM_PAYLOAD_MEMFD:
+
+          msg_ptr = mmap(NULL, item->memfd.size, PROT_READ, MAP_SHARED, item->memfd.fd, 0);
+
+          if (msg_ptr == MAP_FAILED)
+            {
+              g_print ("mmap() fd=%i failed:%m", item->memfd.fd);
+              break;
+            }
+
+          g_kdbus_add_msg_part (kdbus, msg_ptr, item->memfd.size);
+          ret_size += item->memfd.size;
+
+          break;
+
+        /* KDBUS_ITEM_FDS */
+        case KDBUS_ITEM_FDS:
+
+          kdbus->priv->num_fds = data_size / sizeof(int);
+          kdbus->priv->fds = g_malloc0 (sizeof(int) * kdbus->priv->num_fds);
+          memcpy(kdbus->priv->fds, item->fds, sizeof(int) * kdbus->priv->num_fds);
+
+          break;
+
+        /* All of the following items, like CMDLINE,
+           CGROUP, etc. need some GDBUS API extensions and
+           should be implemented in the future */
+        case KDBUS_ITEM_CREDS:
+        case KDBUS_ITEM_TIMESTAMP:
+        case KDBUS_ITEM_PID_COMM:
+        case KDBUS_ITEM_TID_COMM:
+        case KDBUS_ITEM_EXE:
+        case KDBUS_ITEM_CMDLINE:
+        case KDBUS_ITEM_CGROUP:
+        case KDBUS_ITEM_AUDIT:
+        case KDBUS_ITEM_CAPS:
+        case KDBUS_ITEM_SECLABEL:
+        case KDBUS_ITEM_CONN_NAME:
+        case KDBUS_ITEM_NAME:
+          break;
+
+        default:
+          g_error ("[KDBUS] DBUS_PAYLOAD: Unknown filed - %lld", item->type);
+          break;
+        }
+    }
+
+  /* Override information from the user header with data from the kernel */
+
+  if (kdbus->priv->kmsg->src_id == KDBUS_SRC_ID_KERNEL)
+    g_string_printf (kdbus->priv->msg_sender, "org.freedesktop.DBus");
+  else
+    g_string_printf (kdbus->priv->msg_sender, ":1.%" G_GUINT64_FORMAT, (guint64) kdbus->priv->kmsg->src_id);
+
+  if (destination)
+    g_string_printf (kdbus->priv->msg_destination, "%s", destination);
+  else if (kdbus->priv->kmsg->dst_id == KDBUS_DST_ID_BROADCAST)
+    /* for broadcast messages we don't have to set destination */
+    ;
+  else if (kdbus->priv->kmsg->dst_id == KDBUS_DST_ID_NAME)
+    g_string_printf (kdbus->priv->msg_destination, ":1.%" G_GUINT64_FORMAT, (guint64) kdbus->priv->unique_id);
+  else
+    g_string_printf (kdbus->priv->msg_destination, ":1.%" G_GUINT64_FORMAT, (guint64) kdbus->priv->kmsg->dst_id);
+
+  return ret_size;
+}
+
+
+/**
+ * _g_kdbus_receive:
+ *
+ */
+gssize
+_g_kdbus_receive (GKdbus        *kdbus,
+                  GCancellable  *cancellable,
+                  GError       **error)
+{
+  struct kdbus_cmd_recv recv = {};
+  gssize size = 0;
+
+  if (g_cancellable_set_error_if_cancelled (cancellable, error))
+    return -1;
+
+  again:
+    if (ioctl(kdbus->priv->fd, KDBUS_CMD_MSG_RECV, &recv) < 0)
+      {
+        if (errno == EINTR || errno == EAGAIN)
+          goto again;
+
+        g_set_error (error, G_IO_ERROR, g_io_error_from_errno(errno),_("Error receiving message - KDBUS_CMD_MSG_RECV error"));
+        return -1;
+      }
+
+    kdbus->priv->kmsg = (struct kdbus_msg *)((guint8 *)kdbus->priv->kdbus_buffer + recv.offset);
+
+    if (kdbus->priv->kmsg->payload_type == KDBUS_PAYLOAD_DBUS)
+      size = g_kdbus_decode_dbus_msg (kdbus);
+    else if (kdbus->priv->kmsg->payload_type == KDBUS_PAYLOAD_KERNEL)
+      size = g_kdbus_decode_kernel_msg (kdbus);
+    else
+      g_error ("[KDBUS] Unknown payload type: %llu", kdbus->priv->kmsg->payload_type);
+
+    return size;
+}
+
+
+/**
+ * _g_kdbus_send:
+ * Returns: size of data sent or -1 when error
+ */
+gsize
+_g_kdbus_send (GDBusWorker   *worker,
+               GKdbus        *kdbus,
+               GDBusMessage  *dbus_msg,
+               gchar         *blob,
+               gsize          blob_size,
+               GUnixFDList   *fd_list,
+               GCancellable  *cancellable,
+               GError       **error)
+{
+  struct kdbus_msg* kmsg;
+  struct kdbus_item *item;
+  guint64 kmsg_size = 0;
+  const gchar *name;
+  gboolean use_memfd = FALSE;
+  guint64 dst_id = KDBUS_DST_ID_BROADCAST;
+
+  g_return_val_if_fail (G_IS_KDBUS (kdbus), -1);
+
+  if (g_cancellable_set_error_if_cancelled (cancellable, error))
+    return -1;
+
+
+  /*
+   * If systemd-bus-driverd from systemd isn't available
+   * try to process the bus driver messages locally
+   */
+#ifndef SYSTEMD_BUS_DRIVERD
+  if (g_strcmp0(g_dbus_message_get_destination(dbus_msg), "org.freedesktop.DBus") == 0)
+    {
+      if (g_kdbus_bus_driver (worker, kdbus, dbus_msg))
+        return blob_size;
+      else
+        return -1;
+    }
+#else
+    if ((g_strcmp0(g_dbus_message_get_destination(dbus_msg), "org.freedesktop.DBus") == 0) &&
+        (g_strcmp0(g_dbus_message_get_member(dbus_msg), "Hello") == 0))
+      {
+        g_kdbus_take_fd (kdbus);
+      }
+#endif
+
+
+  /*
+   * check destination
+   */
+  if ((name = g_dbus_message_get_destination(dbus_msg)))
+    {
+      dst_id = KDBUS_DST_ID_NAME;
+      if ((name[0] == ':') && (name[1] == '1') && (name[2] == '.'))
+        {
+          dst_id = strtoull(&name[3], NULL, 10);
+          name=NULL;
+        }
+    }
+
+
+  /*
+   * check whether we should use memfd transport (for messages > 512K)
+   */
+  if (name && (blob_size > 524288))
+    use_memfd = TRUE;
+
+
+  /*
+   * check and set message size
+   */
+  kmsg_size = sizeof(struct kdbus_msg);
+  if (use_memfd)
+    {
+      kmsg_size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_vec));   /* header */
+      kmsg_size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_memfd)); /* body */
+    }
+  else
+    kmsg_size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_vec));   /* header + body */
+
+  if (fd_list != NULL && g_unix_fd_list_get_length (fd_list) > 0)
+    kmsg_size += ALIGN8(G_STRUCT_OFFSET(struct kdbus_item, fds) + sizeof(int) * g_unix_fd_list_get_length(fd_list));
+
+  if (name)
+    kmsg_size += KDBUS_ITEM_SIZE(strlen(name) + 1);
+  else if (dst_id == KDBUS_DST_ID_BROADCAST)
+    kmsg_size += ALIGN8(G_STRUCT_OFFSET(struct kdbus_item, bloom_filter) +
+                        G_STRUCT_OFFSET(struct kdbus_bloom_filter, data) +
+                        kdbus->priv->bloom_size);
+
+  kmsg = malloc(kmsg_size);
+  if (!kmsg)
+    g_error ("[KDBUS] kmsg malloc error");
+
+
+  /*
+   * set message header
+   */
+  memset(kmsg, 0, kmsg_size);
+  kmsg->size = kmsg_size;
+  kmsg->payload_type = KDBUS_PAYLOAD_DBUS;
+  kmsg->dst_id = name ? 0 : dst_id;
+  kmsg->src_id = kdbus->priv->unique_id;
+  kmsg->cookie = g_dbus_message_get_serial(dbus_msg);
+  kmsg->priority = 0;
+
+
+  /*
+   * set message flags
+   */
+  kmsg->flags = ((g_dbus_message_get_flags (dbus_msg) & G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED) ? 0 : KDBUS_MSG_FLAGS_EXPECT_REPLY) |
+                ((g_dbus_message_get_flags (dbus_msg) & G_DBUS_MESSAGE_FLAGS_NO_AUTO_START) ? KDBUS_MSG_FLAGS_NO_AUTO_START : 0);
+
+  if ((kmsg->flags) & KDBUS_MSG_FLAGS_EXPECT_REPLY)
+    kmsg->timeout_ns = 2000000000;
+  else
+    kmsg->cookie_reply = g_dbus_message_get_reply_serial(dbus_msg);
+
+
+  /*
+   * append payload
+   */
+  item = kmsg->items;
+  if (use_memfd)
+    {
+      gint32 body_size;
+
+      if (!g_kdbus_alloc_memfd (kdbus))
+        g_error ("Can't alloc memfd");
+
+      /* split blob to header and body */
+      memcpy (&body_size, blob+4, 4);
+      body_size = GINT32_FROM_LE (body_size);
+
+      /*
+       * write blob and seal
+       * We should build up whole messsage directly in memfd object without
+       * making copy but memfd will be completly reworked soon [1],
+       * so we're still waiting for this:
+       *
+       * [1] https://code.google.com/p/d-bus/source/browse/TODO
+       */
+
+      if (write(kdbus->priv->memfd, blob + (blob_size-body_size), body_size) <= 0)
+        g_error ("Can't write data to memfd object");
+
+      if (ioctl(kdbus->priv->memfd, KDBUS_CMD_MEMFD_SEAL_SET, 1) < 0)
+        g_error ("Can't seal memfd object");
+
+      /* message header in its entirety must be contained in a single PAYLOAD_VEC item */
+      g_kdbus_append_payload_vec (&item, blob, blob_size - body_size);
+      /* send body as as PAYLOAD_MEMFD item */
+      g_kdbus_append_payload_memfd (&item, kdbus->priv->memfd, body_size);
+    }
+  else
+    {
+      /* if we don't use memfd, send whole message as a PAYLOAD_VEC item */
+      g_kdbus_append_payload_vec (&item, blob, blob_size);
+    }
+
+
+  /*
+   * append destination or bloom filters
+   */
+  if (name)
+    g_kdbus_append_destination (&item, name, strlen(name));
+  else if (dst_id == KDBUS_DST_ID_BROADCAST)
+    {
+      struct kdbus_bloom_filter *bloom_filter;
+
+      bloom_filter = g_kdbus_append_bloom (&item, kdbus->priv->bloom_size);
+      g_kdbus_setup_bloom (kdbus, dbus_msg, bloom_filter);
+    }
+
+
+  /*
+   * append fds if any
+   */
+  if (fd_list != NULL && g_unix_fd_list_get_length (fd_list) > 0)
+    g_kdbus_append_fds (&item, fd_list);
+
+
+  /*
+   * send message
+   */
+again:
+  if (ioctl(kdbus->priv->fd, KDBUS_CMD_MSG_SEND, kmsg))
+    {
+      GString *error_name;
+      error_name = g_string_new (NULL);
+
+      if(errno == EINTR)
+        {
+          g_string_free (error_name,TRUE);
+          goto again;
+        }
+      else if (errno == ENXIO)
+        {
+          g_string_printf (error_name, "Name %s does not exist", g_dbus_message_get_destination(dbus_msg));
+          g_kdbus_generate_local_error (worker,
+                                        dbus_msg,
+                                        g_variant_new ("(s)",error_name->str),
+                                        G_DBUS_ERROR_SERVICE_UNKNOWN);
+          g_string_free (error_name,TRUE);
+          return 0;
+        }
+      else if ((errno == ESRCH) || (errno == EADDRNOTAVAIL))
+        {
+          if (kmsg->flags & KDBUS_MSG_FLAGS_NO_AUTO_START)
+            {
+              g_string_printf (error_name, "Name %s does not exist", g_dbus_message_get_destination(dbus_msg));
+              g_kdbus_generate_local_error (worker,
+                                            dbus_msg,
+                                            g_variant_new ("(s)",error_name->str),
+                                            G_DBUS_ERROR_SERVICE_UNKNOWN);
+              g_string_free (error_name,TRUE);
+              return 0;
+            }
+          else
+            {
+              g_string_printf (error_name, "The name %s was not provided by any .service files", g_dbus_message_get_destination(dbus_msg));
+              g_kdbus_generate_local_error (worker,
+                                            dbus_msg,
+                                            g_variant_new ("(s)",error_name->str),
+                                            G_DBUS_ERROR_SERVICE_UNKNOWN);
+              g_string_free (error_name,TRUE);
+              return 0;
+            }
+        }
+
+      g_print ("[KDBUS] ioctl error sending kdbus message:%d (%m)\n",errno);
+      g_set_error (error, G_IO_ERROR, g_io_error_from_errno(errno), _("Error sending message - KDBUS_CMD_MSG_SEND error"));
+      return -1;
+    }
+
+  if (kdbus->priv->memfd >= 0)
+    close(kdbus->priv->memfd);
+
+  free(kmsg);
+
+  return blob_size;
+}
diff --git a/gio/gkdbus.h b/gio/gkdbus.h
new file mode 100644
index 0000000..e7bac6f
--- /dev/null
+++ b/gio/gkdbus.h
@@ -0,0 +1,108 @@
+/*  GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2013 Samsung Electronics
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Author: Michal Eljasiewicz   <m.eljasiewic@samsung.com>
+ * Author: Lukasz Skalski       <l.skalski@samsung.com>
+ */
+
+#ifndef __G_KDBUS_H__
+#define __G_KDBUS_H__
+
+#if !defined (GIO_COMPILATION)
+#error "gkdbus.h is a private header file."
+#endif
+
+#include <gio/giotypes.h>
+#include "gdbusprivate.h"
+
+G_BEGIN_DECLS
+
+#define G_TYPE_KDBUS                                       (_g_kdbus_get_type ())
+#define G_KDBUS(o)                                         (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_KDBUS, GKdbus))
+#define G_KDBUS_CLASS(k)                                   (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_KDBUS, GKdbusClass))
+#define G_KDBUS_GET_CLASS(o)                               (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_KDBUS, GKdbusClass))
+#define G_IS_KDBUS(o)                                      (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_KDBUS))
+#define G_IS_KDBUS_CLASS(k)                                (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_KDBUS))
+
+typedef struct _GKdbus                                      GKdbus;
+typedef struct _GKdbusClass                                 GKdbusClass;
+typedef struct _GKdbusPrivate                               GKdbusPrivate;
+
+struct _GKdbusClass
+{
+  GObjectClass parent_class;
+};
+
+struct _GKdbus
+{
+  GObject parent_instance;
+  GKdbusPrivate *priv;
+};
+
+typedef struct
+{
+  gchar  *data;
+  gsize   size;
+} msg_part;
+
+GType                                   _g_kdbus_get_type                  (void) G_GNUC_CONST;
+
+gboolean                                _g_kdbus_open                      (GKdbus       *kdbus,
+                                                                            const gchar  *address,
+                                                                            GError      **error);
+
+gboolean                                _g_kdbus_close                     (GKdbus  *kdbus,
+                                                                            GError **error);
+
+gboolean                                _g_kdbus_is_closed                 (GKdbus  *kdbus);
+
+
+gssize                                  _g_kdbus_receive                   (GKdbus        *kdbus,
+                                                                            GCancellable  *cancellable,
+                                                                            GError       **error);
+
+gsize                                   _g_kdbus_send                      (GDBusWorker   *worker,
+                                                                            GKdbus        *kdbus,
+                                                                            GDBusMessage  *dbus_msg,
+                                                                            gchar         *blob,
+                                                                            gsize          blob_size,
+                                                                            GUnixFDList   *fd_list,
+                                                                            GCancellable  *cancellable,
+                                                                            GError       **error);
+
+GSource *                               _g_kdbus_create_source             (GKdbus        *kdbus,
+                                                                            GIOCondition   condition,
+                                                                            GCancellable  *cancellable);
+
+gchar *                                 _g_kdbus_hexdump_all_items         (GSList        *kdbus_msg_items);
+
+void                                    _g_kdbus_release_kmsg              (GKdbus        *kdbus);
+
+void                                    _g_kdbus_attach_fds_to_msg         (GKdbus        *kdbus,
+                                                                            GUnixFDList  **fd_list);
+
+GSList *                                _g_kdbus_get_last_msg_items        (GKdbus        *kdbus);
+
+gchar *                                 _g_kdbus_get_last_msg_sender       (GKdbus        *kdbus);
+
+gchar *                                 _g_kdbus_get_last_msg_destination  (GKdbus        *kdbus);
+
+G_END_DECLS
+
+#endif /* __G_KDBUS_H__ */
diff --git a/gio/gkdbusconnection.c b/gio/gkdbusconnection.c
new file mode 100644
index 0000000..bdd4685
--- /dev/null
+++ b/gio/gkdbusconnection.c
@@ -0,0 +1,227 @@
+/*  GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2013 Samsung Electronics
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Author: Michal Eljasiewicz   <m.eljasiewic@samsung.com>
+ * Author: Lukasz Skalski       <l.skalski@samsung.com>
+ */
+
+#include "config.h"
+#include "gkdbusconnection.h"
+#include "gunixconnection.h"
+
+/**
+ * SECTION:gkdbusconnection
+ * @short_description: A kdbus connection
+ * @include: gio/gio.h
+ * @see_also: #GIOStream, #GKdbusClient
+ *
+ * #GKdbusConnection is a #GIOStream for a connected kdbus bus.
+ */
+
+#define g_kdbus_connection_get_type _g_kdbus_connection_get_type
+G_DEFINE_TYPE (GKdbusConnection, g_kdbus_connection, G_TYPE_IO_STREAM);
+
+struct _GKdbusConnectionPrivate
+{
+  GKdbus    *kdbus;
+  gboolean   in_dispose;
+};
+
+
+/**
+ * g_kdbus_connection_new:
+ *
+ */
+GKdbusConnection *
+_g_kdbus_connection_new (void)
+{
+  return g_object_new(G_TYPE_KDBUS_CONNECTION,NULL);
+}
+
+
+/**
+ * g_kdbus_connection_connect:
+ *
+ */
+gboolean
+_g_kdbus_connection_connect (GKdbusConnection  *connection,
+                             const gchar       *address,
+                             GCancellable      *cancellable,
+                             GError           **error)
+{
+  g_return_val_if_fail (G_IS_KDBUS_CONNECTION (connection), FALSE);
+
+  return _g_kdbus_open (connection->priv->kdbus,address,error);
+}
+
+
+/**
+ * g_kdbus_connection_constructed:
+ *
+ */
+static void
+g_kdbus_connection_constructed (GObject  *object)
+{
+  GKdbusConnection *connection = G_KDBUS_CONNECTION (object);
+
+  g_assert (connection->priv->kdbus != NULL);
+}
+
+
+/**
+ * g_kdbus_connection_finalize:
+ *
+ */
+static void
+g_kdbus_connection_finalize (GObject  *object)
+{
+  GKdbusConnection *connection = G_KDBUS_CONNECTION (object);
+
+  g_object_unref (connection->priv->kdbus);
+
+  G_OBJECT_CLASS (g_kdbus_connection_parent_class)->finalize (object);
+}
+
+
+/**
+ * g_kdbus_connection_dispose:
+ *
+ */
+static void
+g_kdbus_connection_dispose (GObject  *object)
+{
+  GKdbusConnection *connection = G_KDBUS_CONNECTION (object);
+
+  connection->priv->in_dispose = TRUE;
+
+  G_OBJECT_CLASS (g_kdbus_connection_parent_class)
+    ->dispose (object);
+
+  connection->priv->in_dispose = FALSE;
+}
+
+
+/**
+ * g_kdbus_connection_close:
+ *
+ */
+static gboolean
+g_kdbus_connection_close (GIOStream     *stream,
+                          GCancellable  *cancellable,
+                          GError       **error)
+{
+  GKdbusConnection *connection = G_KDBUS_CONNECTION (stream);
+
+  if (connection->priv->in_dispose)
+    return TRUE;
+
+  return _g_kdbus_close (connection->priv->kdbus, error);
+}
+
+
+/**
+ * g_kdbus_connection_close_async:
+ *
+ */
+static void
+g_kdbus_connection_close_async (GIOStream            *stream,
+                                int                   io_priority,
+                                GCancellable         *cancellable,
+                                GAsyncReadyCallback   callback,
+                                gpointer              user_data)
+{
+  GTask *task;
+  GIOStreamClass *class;
+  GError *error;
+
+  class = G_IO_STREAM_GET_CLASS (stream);
+
+  task = g_task_new (stream, cancellable, callback, user_data);
+
+  error = NULL;
+  if (class->close_fn &&
+      !class->close_fn (stream, cancellable, &error))
+    g_task_return_error (task, error);
+  else
+    g_task_return_boolean (task, TRUE);
+
+  g_object_unref (task);
+}
+
+
+/**
+ * g_kdbus_connection_close_finish:
+ *
+ */
+static gboolean
+g_kdbus_connection_close_finish (GIOStream     *stream,
+                                 GAsyncResult  *result,
+                                 GError       **error)
+{
+  return g_task_propagate_boolean (G_TASK (result), error);
+}
+
+
+/**
+ * g_kdbus_connection_class_init:
+ *
+ */
+static void
+g_kdbus_connection_class_init (GKdbusConnectionClass  *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GIOStreamClass *stream_class = G_IO_STREAM_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (GKdbusConnectionPrivate));
+
+  gobject_class->constructed = g_kdbus_connection_constructed;
+  gobject_class->finalize = g_kdbus_connection_finalize;
+  gobject_class->dispose = g_kdbus_connection_dispose;
+
+  stream_class->close_fn = g_kdbus_connection_close;
+  stream_class->close_async = g_kdbus_connection_close_async;
+  stream_class->close_finish = g_kdbus_connection_close_finish;
+}
+
+
+/**
+ * g_kdbus_connection_init:
+ *
+ */
+static void
+g_kdbus_connection_init (GKdbusConnection  *connection)
+{
+  connection->priv = G_TYPE_INSTANCE_GET_PRIVATE (connection,
+                                                  G_TYPE_KDBUS_CONNECTION,
+                                                  GKdbusConnectionPrivate);
+  connection->priv->kdbus = g_object_new(G_TYPE_KDBUS,NULL);
+}
+
+
+/**
+ * g_kdbus_connection_get_kdbus:
+ *
+ */
+GKdbus *
+_g_kdbus_connection_get_kdbus (GKdbusConnection  *connection)
+{
+  g_return_val_if_fail (G_IS_KDBUS_CONNECTION (connection), NULL);
+
+  return connection->priv->kdbus;
+}
diff --git a/gio/gkdbusconnection.h b/gio/gkdbusconnection.h
new file mode 100644
index 0000000..7e3e863
--- /dev/null
+++ b/gio/gkdbusconnection.h
@@ -0,0 +1,73 @@
+/*  GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2013 Samsung Electronics
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Author: Michal Eljasiewicz   <m.eljasiewic@samsung.com>
+ * Author: Lukasz Skalski       <l.skalski@samsung.com>
+ */
+
+#ifndef __G_KDBUS_CONNECTION_H__
+#define __G_KDBUS_CONNECTION_H__
+
+#if !defined (GIO_COMPILATION)
+#error "gkdbusconnection.h is a private header file."
+#endif
+
+#include <glib-object.h>
+#include <gio/gkdbus.h>
+#include <gio/giostream.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_KDBUS_CONNECTION              (_g_kdbus_connection_get_type ())
+#define G_KDBUS_CONNECTION(o)                (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_KDBUS_CONNECTION, GKdbusConnection))
+#define G_KDBUS_CONNECTION_CLASS(k)          (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_KDBUS_CONNECTION, GKdbusConnectionClass))
+#define G_KDBUS_CONNECTION_GET_CLASS(o)      (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_KDBUS_CONNECTION, GKdbusConnectionClass))
+#define G_IS_KDBUS_CONNECTION(o)             (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_KDBUS_CONNECTION))
+#define G_IS_KDBUS_CONNECTION_CLASS(k)       (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_KDBUS_CONNECTION))
+
+typedef struct _GKdbusConnection              GKdbusConnection;
+typedef struct _GKdbusConnectionClass         GKdbusConnectionClass;
+typedef struct _GKdbusConnectionPrivate       GKdbusConnectionPrivate;
+
+struct _GKdbusConnectionClass
+{
+  GIOStreamClass parent_class;
+};
+
+struct _GKdbusConnection
+{
+  GIOStream parent_instance;
+  GKdbusConnectionPrivate *priv;
+};
+
+
+GType              _g_kdbus_connection_get_type                  (void) G_GNUC_CONST;
+
+GKdbusConnection * _g_kdbus_connection_new                       (void);
+
+gboolean           _g_kdbus_connection_connect                   (GKdbusConnection  *connection,
+                                                                  const gchar       *address,
+                                                                  GCancellable      *cancellable,
+                                                                  GError           **error);
+
+GKdbus *           _g_kdbus_connection_get_kdbus                 (GKdbusConnection  *connection);
+
+G_END_DECLS
+
+#endif /* __G_KDBUS_CONNECTION_H__ */
diff --git a/gio/kdbus.h b/gio/kdbus.h
new file mode 100644
index 0000000..f128d3b
--- /dev/null
+++ b/gio/kdbus.h
@@ -0,0 +1,955 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Linux Foundation
+ * Copyright (C) 2013 Lennart Poettering
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ *
+ * "Everything should be made as simple as possible, but not simpler."
+ *   -- Albert Einstein
+ */
+
+#ifndef _KDBUS_H_
+#define _KDBUS_H_
+
+#ifndef __KERNEL__
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <linux/types.h>
+#endif
+
+#define KDBUS_IOCTL_MAGIC		0x95
+#define KDBUS_SRC_ID_KERNEL		(0)
+#define KDBUS_DST_ID_NAME		(0)
+#define KDBUS_MATCH_ID_ANY		(~0ULL)
+#define KDBUS_DST_ID_BROADCAST		(~0ULL)
+
+/**
+ * struct kdbus_notify_id_change - name registry change message
+ * @id:			New or former owner of the name
+ * @flags:		flags field from KDBUS_HELLO_*
+ *
+ * Sent from kernel to userspace when the owner or activator of
+ * a well-known name changes.
+ *
+ * Attached to:
+ *   KDBUS_ITEM_ID_ADD
+ *   KDBUS_ITEM_ID_REMOVE
+ */
+struct kdbus_notify_id_change {
+	__u64 id;
+	__u64 flags;
+};
+
+/**
+ * struct kdbus_notify_name_change - name registry change message
+ * @old:		ID and flags of former owner of a name
+ * @new:		ID and flags of new owner of a name
+ * @name:		Well-known name
+ *
+ * Sent from kernel to userspace when the owner or activator of
+ * a well-known name changes.
+ *
+ * Attached to:
+ *   KDBUS_ITEM_NAME_ADD
+ *   KDBUS_ITEM_NAME_REMOVE
+ *   KDBUS_ITEM_NAME_CHANGE
+ */
+struct kdbus_notify_name_change {
+	struct kdbus_notify_id_change old;
+	struct kdbus_notify_id_change new;
+	char name[0];
+};
+
+/**
+ * struct kdbus_creds - process credentials
+ * @uid:		User ID
+ * @gid:		Group ID
+ * @pid:		Process ID
+ * @tid:		Thread ID
+ * @starttime:		Starttime of the process
+ *
+ * The starttime of the process PID. This is useful to detect PID overruns
+ * from the client side. i.e. if you use the PID to look something up in
+ * /proc/$PID/ you can afterwards check the starttime field of it, to ensure
+ * you didn't run into a PID overrun.
+ *
+ * Attached to:
+ *   KDBUS_ITEM_CREDS
+ */
+struct kdbus_creds {
+	__u64 uid;
+	__u64 gid;
+	__u64 pid;
+	__u64 tid;
+	__u64 starttime;
+};
+
+/**
+ * struct kdbus_audit - audit information
+ * @sessionid:		The audit session ID
+ * @loginuid:		The audit login uid
+ *
+ * Attached to:
+ *   KDBUS_ITEM_AUDIT
+ */
+struct kdbus_audit {
+	__u64 sessionid;
+	__u64 loginuid;
+};
+
+/**
+ * struct kdbus_timestamp
+ * @seqnum:		Global per-domain message sequence number
+ * @monotonic_ns:	Monotonic timestamp, in nanoseconds
+ * @realtime_ns:	Realtime timestamp, in nanoseconds
+ *
+ * Attached to:
+ *   KDBUS_ITEM_TIMESTAMP
+ */
+struct kdbus_timestamp {
+	__u64 seqnum;
+	__u64 monotonic_ns;
+	__u64 realtime_ns;
+};
+
+/**
+ * struct kdbus_vec - I/O vector for kdbus payload items
+ * @size:		The size of the vector
+ * @address:		Memory address for memory addresses
+ * @offset:		Offset in the in-message payload memory,
+ *			relative to the message head
+ *
+ * Attached to:
+ *   KDBUS_ITEM_PAYLOAD_VEC
+ */
+struct kdbus_vec {
+	__u64 size;
+	union {
+		__u64 address;
+		__u64 offset;
+	};
+};
+
+/**
+ * struct kdbus_bloom_parameter - bus-wide bloom parameters
+ * @size:		Size of the bit field in bytes (m / 8)
+ * @n_hash:		Number of hash functions used (k)
+ */
+struct kdbus_bloom_parameter {
+	__u64 size;
+	__u64 n_hash;
+};
+
+/**
+ * struct kdbus_bloom_filter - bloom filter containing n elements
+ * @generation:		Generation of the element set in the filter
+ * @data:		Bit field, multiple of 8 bytes
+ */
+struct kdbus_bloom_filter {
+	__u64 generation;
+	__u64 data[0];
+};
+
+/**
+ * struct kdbus_memfd - a kdbus memfd
+ * @size:		The memfd's size
+ * @fd:			The file descriptor number
+ * @__pad:		Padding to ensure proper alignement and size
+ *
+ * Attached to:
+ *   KDBUS_ITEM_PAYLOAD_MEMFD
+ */
+struct kdbus_memfd {
+	__u64 size;
+	int fd;
+	__u32 __pad;
+};
+
+/**
+ * struct kdbus_name - a registered well-known name with its flags
+ * @flags:		Flags from KDBUS_NAME_*
+ * @name:		Well-known name
+ *
+ * Attached to:
+ *   KDBUS_ITEM_NAME
+ */
+struct kdbus_name {
+	__u64 flags;
+	char name[0];
+};
+
+/**
+ * struct kdbus_policy_access - policy access item
+ * @type:		One of KDBUS_POLICY_ACCESS_* types
+ * @access:		Access to grant
+ * @id:			For KDBUS_POLICY_ACCESS_USER, the uid
+ *			For KDBUS_POLICY_ACCESS_GROUP, the gid
+ */
+struct kdbus_policy_access {
+	__u64 type;	/* USER, GROUP, WORLD */
+	__u64 access;	/* OWN, TALK, SEE */
+	__u64 id;	/* uid, gid, 0 */
+};
+
+/**
+ * enum kdbus_item_type - item types to chain data in a list
+ * @_KDBUS_ITEM_NULL:		Uninitialized/invalid
+ * @_KDBUS_ITEM_USER_BASE:	Start of user items
+ * @KDBUS_ITEM_PAYLOAD_VEC:	Vector to data
+ * @KDBUS_ITEM_PAYLOAD_OFF:	Data at returned offset to message head
+ * @KDBUS_ITEM_PAYLOAD_MEMFD:	Data as sealed memfd
+ * @KDBUS_ITEM_FDS:		Attached file descriptors
+ * @KDBUS_ITEM_BLOOM_PARAMETER:	Bus-wide bloom parameters, used with
+ *				KDBUS_CMD_BUS_MAKE, carries a
+ *				struct kdbus_bloom_parameter
+ * @KDBUS_ITEM_BLOOM_FILTER:	Bloom filter carried with a message, used to
+ *				match against a bloom mask of a connection,
+ *				carries a struct kdbus_bloom_filter
+ * @KDBUS_ITEM_BLOOM_MASK:	Bloom mask used to match against a message's
+ *				bloom filter
+ * @KDBUS_ITEM_DST_NAME:	Destination's well-known name
+ * @KDBUS_ITEM_MAKE_NAME:	Name of domain, bus, endpoint
+ * @KDBUS_ITEM_MEMFD_NAME:	The human readable name of a memfd (debugging)
+ * @KDBUS_ITEM_ATTACH_FLAGS:	Attach-flags, used for updating which metadata
+ *				a connection subscribes to
+ * @_KDBUS_ITEM_ATTACH_BASE:	Start of metadata attach items
+ * @KDBUS_ITEM_NAME:		Well-know name with flags
+ * @KDBUS_ITEM_ID:		Connection ID
+ * @KDBUS_ITEM_TIMESTAMP:	Timestamp
+ * @KDBUS_ITEM_CREDS:		Process credential
+ * @KDBUS_ITEM_PID_COMM:	Process ID "comm" identifier
+ * @KDBUS_ITEM_TID_COMM:	Thread ID "comm" identifier
+ * @KDBUS_ITEM_EXE:		The path of the executable
+ * @KDBUS_ITEM_CMDLINE:		The process command line
+ * @KDBUS_ITEM_CGROUP:		The croup membership
+ * @KDBUS_ITEM_CAPS:		The process capabilities
+ * @KDBUS_ITEM_SECLABEL:	The security label
+ * @KDBUS_ITEM_AUDIT:		The audit IDs
+ * @KDBUS_ITEM_CONN_NAME:	The connection's human-readable name (debugging)
+ * @_KDBUS_ITEM_POLICY_BASE:	Start of policy items
+ * @KDBUS_ITEM_POLICY_ACCESS:	Policy access block
+ * @_KDBUS_ITEM_KERNEL_BASE:	Start of kernel-generated message items
+ * @KDBUS_ITEM_NAME_ADD:	Notify in struct kdbus_notify_name_change
+ * @KDBUS_ITEM_NAME_REMOVE:	Notify in struct kdbus_notify_name_change
+ * @KDBUS_ITEM_NAME_CHANGE:	Notify in struct kdbus_notify_name_change
+ * @KDBUS_ITEM_ID_ADD:		Notify in struct kdbus_notify_id_change
+ * @KDBUS_ITEM_ID_REMOVE:	Notify in struct kdbus_notify_id_change
+ * @KDBUS_ITEM_REPLY_TIMEOUT:	Timeout has been reached
+ * @KDBUS_ITEM_REPLY_DEAD:	Destination died
+ */
+enum kdbus_item_type {
+	_KDBUS_ITEM_NULL,
+	_KDBUS_ITEM_USER_BASE,
+	KDBUS_ITEM_PAYLOAD_VEC	= _KDBUS_ITEM_USER_BASE,
+	KDBUS_ITEM_PAYLOAD_OFF,
+	KDBUS_ITEM_PAYLOAD_MEMFD,
+	KDBUS_ITEM_FDS,
+	KDBUS_ITEM_BLOOM_PARAMETER,
+	KDBUS_ITEM_BLOOM_FILTER,
+	KDBUS_ITEM_BLOOM_MASK,
+	KDBUS_ITEM_DST_NAME,
+	KDBUS_ITEM_MAKE_NAME,
+	KDBUS_ITEM_MEMFD_NAME,
+	KDBUS_ITEM_ATTACH_FLAGS,
+
+	_KDBUS_ITEM_ATTACH_BASE	= 0x1000,
+	KDBUS_ITEM_NAME		= _KDBUS_ITEM_ATTACH_BASE,
+	KDBUS_ITEM_ID,
+	KDBUS_ITEM_TIMESTAMP,
+	KDBUS_ITEM_CREDS,
+	KDBUS_ITEM_PID_COMM,
+	KDBUS_ITEM_TID_COMM,
+	KDBUS_ITEM_EXE,
+	KDBUS_ITEM_CMDLINE,
+	KDBUS_ITEM_CGROUP,
+	KDBUS_ITEM_CAPS,
+	KDBUS_ITEM_SECLABEL,
+	KDBUS_ITEM_AUDIT,
+	KDBUS_ITEM_CONN_NAME,
+
+	_KDBUS_ITEM_POLICY_BASE	= 0x2000,
+	KDBUS_ITEM_POLICY_ACCESS = _KDBUS_ITEM_POLICY_BASE,
+
+	_KDBUS_ITEM_KERNEL_BASE	= 0x8000,
+	KDBUS_ITEM_NAME_ADD	= _KDBUS_ITEM_KERNEL_BASE,
+	KDBUS_ITEM_NAME_REMOVE,
+	KDBUS_ITEM_NAME_CHANGE,
+	KDBUS_ITEM_ID_ADD,
+	KDBUS_ITEM_ID_REMOVE,
+	KDBUS_ITEM_REPLY_TIMEOUT,
+	KDBUS_ITEM_REPLY_DEAD,
+};
+
+/**
+ * struct kdbus_item - chain of data blocks
+ * @size:		Overall data record size
+ * @type:		Kdbus_item type of data
+ * @data:		Generic bytes
+ * @data32:		Generic 32 bit array
+ * @data64:		Generic 64 bit array
+ * @str:		Generic string
+ * @id:			Connection ID
+ * @vec:		KDBUS_ITEM_PAYLOAD_VEC
+ * @creds:		KDBUS_ITEM_CREDS
+ * @audit:		KDBUS_ITEM_AUDIT
+ * @timestamp:		KDBUS_ITEM_TIMESTAMP
+ * @name:		KDBUS_ITEM_NAME
+ * @bloom_parameter:	KDBUS_ITEM_BLOOM_PARAMETER
+ * @bloom_filter:	KDBUS_ITEM_BLOOM_FILTER
+ * @memfd:		KDBUS_ITEM_PAYLOAD_MEMFD
+ * @name_change:	KDBUS_ITEM_NAME_ADD
+ *			KDBUS_ITEM_NAME_REMOVE
+ *			KDBUS_ITEM_NAME_CHANGE
+ * @id_change:		KDBUS_ITEM_ID_ADD
+ *			KDBUS_ITEM_ID_REMOVE
+ * @policy:		KDBUS_ITEM_POLICY_ACCESS
+ */
+struct kdbus_item {
+	__u64 size;
+	__u64 type;
+	union {
+		__u8 data[0];
+		__u32 data32[0];
+		__u64 data64[0];
+		char str[0];
+
+		__u64 id;
+		struct kdbus_vec vec;
+		struct kdbus_creds creds;
+		struct kdbus_audit audit;
+		struct kdbus_timestamp timestamp;
+		struct kdbus_name name;
+		struct kdbus_bloom_parameter bloom_parameter;
+		struct kdbus_bloom_filter bloom_filter;
+		struct kdbus_memfd memfd;
+		int fds[0];
+		struct kdbus_notify_name_change name_change;
+		struct kdbus_notify_id_change id_change;
+		struct kdbus_policy_access policy_access;
+	};
+};
+
+/**
+ * enum kdbus_msg_flags - type of message
+ * @KDBUS_MSG_FLAGS_EXPECT_REPLY:	Expect a reply message, used for
+ *					method calls. The userspace-supplied
+ *					cookie identifies the message and the
+ *					respective reply carries the cookie
+ *					in cookie_reply
+ * @KDBUS_MSG_FLAGS_SYNC_REPLY:		Wait for destination connection to
+ *					reply to this message. The
+ *					KDBUS_CMD_MSG_SEND ioctl() will block
+ *					until the reply is received, and
+ *					offset_reply in struct kdbus_msg will
+ *					yield the offset in the sender's pool
+ *					where the reply can be found.
+ *					This flag is only valid if
+ *					@KDBUS_MSG_FLAGS_EXPECT_REPLY is set as
+ *					well.
+ * @KDBUS_MSG_FLAGS_NO_AUTO_START:	Do not start a service, if the addressed
+ *					name is not currently active
+ */
+enum kdbus_msg_flags {
+	KDBUS_MSG_FLAGS_EXPECT_REPLY	= 1 << 0,
+	KDBUS_MSG_FLAGS_SYNC_REPLY	= 1 << 1,
+	KDBUS_MSG_FLAGS_NO_AUTO_START	= 1 << 2,
+};
+
+/**
+ * enum kdbus_payload_type - type of payload carried by message
+ * @KDBUS_PAYLOAD_KERNEL:	Kernel-generated simple message
+ * @KDBUS_PAYLOAD_DBUS:		D-Bus marshalling "DBusDBus"
+ */
+enum kdbus_payload_type {
+	KDBUS_PAYLOAD_KERNEL,
+	KDBUS_PAYLOAD_DBUS	= 0x4442757344427573ULL,
+};
+
+/**
+ * struct kdbus_msg - the representation of a kdbus message
+ * @size:		Total size of the message
+ * @flags:		Message flags (KDBUS_MSG_FLAGS_*)
+ * @priority:		Message queue priority value
+ * @dst_id:		64-bit ID of the destination connection
+ * @src_id:		64-bit ID of the source connection
+ * @payload_type:	Payload type (KDBUS_PAYLOAD_*)
+ * @cookie:		Userspace-supplied cookie, for the connection
+ *			to identify its messages
+ * @timeout_ns:		The time to wait for a message reply from the peer.
+ *			If there is no reply, a kernel-generated message
+ *			with an attached KDBUS_ITEM_REPLY_TIMEOUT item
+ *			is sent to @src_id.
+ * @cookie_reply:	A reply to the requesting message with the same
+ *			cookie. The requesting connection can match its
+ *			request and the reply with this value
+ * @offset_reply:	If KDBUS_MSG_FLAGS_EXPECT_REPLY, this field will
+ *			contain the offset in the sender's pool where the
+ *			reply is stored.
+ * @items:		A list of kdbus_items containing the message payload
+ */
+struct kdbus_msg {
+	__u64 size;
+	__u64 flags;
+	__s64 priority;
+	__u64 dst_id;
+	__u64 src_id;
+	__u64 payload_type;
+	__u64 cookie;
+	union {
+		__u64 timeout_ns;
+		__u64 cookie_reply;
+		__u64 offset_reply;
+	};
+	struct kdbus_item items[0];
+} __attribute__((aligned(8)));
+
+/**
+ * enum kdbus_recv_flags - flags for de-queuing messages
+ * @KDBUS_RECV_PEEK:		Return the next queued message without
+ *				actually de-queuing it, and without installing
+ *				any file descriptors or other resources. It is
+ *				usually used to determine the activating
+ *				connection of a bus name.
+ * @KDBUS_RECV_DROP:		Drop and free the next queued message and all
+ *				its resources without actually receiving it.
+ * @KDBUS_RECV_USE_PRIORITY:	Only de-queue messages with the specified or
+ *				higher priority (lowest values); if not set,
+ *				the priority value is ignored.
+ */
+enum kdbus_recv_flags {
+	KDBUS_RECV_PEEK		= 1 <<  0,
+	KDBUS_RECV_DROP		= 1 <<  1,
+	KDBUS_RECV_USE_PRIORITY	= 1 <<  2,
+};
+
+/**
+ * struct kdbus_cmd_recv - struct to de-queue a buffered message
+ * @flags:		KDBUS_RECV_* flags
+ * @priority:		Minimum priority of the messages to de-queue. Lowest
+ *			values have the highest priority.
+ * @offset:		Returned offset in the pool where the message is
+ *			stored. The user must use KDBUS_CMD_FREE to free
+ *			the allocated memory.
+ *
+ * This struct is used with the KDBUS_CMD_MSG_RECV ioctl.
+ */
+struct kdbus_cmd_recv {
+	__u64 flags;
+	__s64 priority;
+	__u64 offset;
+} __attribute__((aligned(8)));
+
+/**
+ * enum kdbus_policy_access_type - permissions of a policy record
+ * @_KDBUS_POLICY_ACCESS_NULL:	Uninitialized/invalid
+ * @KDBUS_POLICY_ACCESS_USER:	Grant access to a uid
+ * @KDBUS_POLICY_ACCESS_GROUP:	Grant access to gid
+ * @KDBUS_POLICY_ACCESS_WORLD:	World-accessible
+ */
+enum kdbus_policy_access_type {
+	_KDBUS_POLICY_ACCESS_NULL,
+	KDBUS_POLICY_ACCESS_USER,
+	KDBUS_POLICY_ACCESS_GROUP,
+	KDBUS_POLICY_ACCESS_WORLD,
+};
+
+/**
+ * enum kdbus_policy_access_flags - mode flags
+ * @KDBUS_POLICY_OWN:		Allow to own a well-known name
+ *				Implies KDBUS_POLICY_TALK and KDBUS_POLICY_SEE
+ * @KDBUS_POLICY_TALK:		Allow communication to a well-known name
+ *				Implies KDBUS_POLICY_SEE
+ * @KDBUS_POLICY_SEE:		Allow to see a well-known name
+ */
+enum kdbus_policy_type {
+	KDBUS_POLICY_SEE	= 0,
+	KDBUS_POLICY_TALK,
+	KDBUS_POLICY_OWN,
+};
+
+/**
+ * enum kdbus_hello_flags - flags for struct kdbus_cmd_hello
+ * @KDBUS_HELLO_ACCEPT_FD:	The connection allows the receiving of
+ *				any passed file descriptors
+ * @KDBUS_HELLO_ACTIVATOR:	Special-purpose connection which registers
+ *				a well-know name for a process to be started
+ *				when traffic arrives
+ * @KDBUS_HELLO_POLICY_HOLDER:	Special-purpose connection which registers
+ *				policy entries for one or multiple names. The
+ *				provided names are not activated, and are not
+ *				registered with the name database
+ * @KDBUS_HELLO_MONITOR:	Special-purpose connection to monitor
+ *				bus traffic
+ */
+enum kdbus_hello_flags {
+	KDBUS_HELLO_ACCEPT_FD		=  1 <<  0,
+	KDBUS_HELLO_ACTIVATOR		=  1 <<  1,
+	KDBUS_HELLO_POLICY_HOLDER	=  1 <<  2,
+	KDBUS_HELLO_MONITOR		=  1 <<  3,
+};
+
+/**
+ * enum kdbus_attach_flags - flags for metadata attachments
+ * @KDBUS_ATTACH_TIMESTAMP:	Timestamp
+ * @KDBUS_ATTACH_CREDS:		Credentials
+ * @KDBUS_ATTACH_NAMES:		Well-known names
+ * @KDBUS_ATTACH_COMM:		The "comm" process identifier
+ * @KDBUS_ATTACH_EXE:		The path of the executable
+ * @KDBUS_ATTACH_CMDLINE:	The process command line
+ * @KDBUS_ATTACH_CGROUP:	The croup membership
+ * @KDBUS_ATTACH_CAPS:		The process capabilities
+ * @KDBUS_ATTACH_SECLABEL:	The security label
+ * @KDBUS_ATTACH_AUDIT:		The audit IDs
+ * @KDBUS_ATTACH_CONN_NAME:	The human-readable connection name
+ * @_KDBUS_ATTACH_ALL:		All of the above
+ */
+enum kdbus_attach_flags {
+	KDBUS_ATTACH_TIMESTAMP		=  1 <<  0,
+	KDBUS_ATTACH_CREDS		=  1 <<  1,
+	KDBUS_ATTACH_NAMES		=  1 <<  2,
+	KDBUS_ATTACH_COMM		=  1 <<  3,
+	KDBUS_ATTACH_EXE		=  1 <<  4,
+	KDBUS_ATTACH_CMDLINE		=  1 <<  5,
+	KDBUS_ATTACH_CGROUP		=  1 <<  6,
+	KDBUS_ATTACH_CAPS		=  1 <<  7,
+	KDBUS_ATTACH_SECLABEL		=  1 <<  8,
+	KDBUS_ATTACH_AUDIT		=  1 <<  9,
+	KDBUS_ATTACH_CONN_NAME		=  1 << 10,
+	_KDBUS_ATTACH_ALL		=  (1 << 11) - 1,
+};
+
+/**
+ * struct kdbus_cmd_hello - struct to say hello to kdbus
+ * @size:		The total size of the structure
+ * @conn_flags:		Connection flags (KDBUS_HELLO_*). The kernel will
+ *			return its capabilities in that field.
+ * @attach_flags:	Mask of metadata to attach to each message sent
+ *			(KDBUS_ATTACH_*)
+ * @bus_flags:		The flags field copied verbatim from the original
+ *			KDBUS_CMD_BUS_MAKE ioctl. It's intended to be useful
+ *			to do negotiation of features of the payload that is
+ *			transferred (kernel  userspace)
+ * @id:			The ID of this connection (kernel  userspace)
+ * @pool_size:		Size of the connection's buffer where the received
+ *			messages are placed
+ * @bloom:		The bloom properties of the bus, specified
+ *			by the bus creator (kernel  userspace)
+ * @id128:		Unique 128-bit ID of the bus (kernel  userspace)
+ * @items:		A list of items
+ *
+ * This struct is used with the KDBUS_CMD_HELLO ioctl.
+ */
+struct kdbus_cmd_hello {
+	__u64 size;
+	__u64 conn_flags;
+	__u64 attach_flags;
+	__u64 bus_flags;
+	__u64 id;
+	__u64 pool_size;
+	struct kdbus_bloom_parameter bloom;
+	__u8 id128[16];
+	struct kdbus_item items[0];
+} __attribute__((aligned(8)));
+
+/**
+ * enum kdbus_make_flags - Flags for KDBUS_CMD_{BUS,EP,NS}_MAKE
+ * @KDBUS_MAKE_ACCESS_GROUP:	Make the device node group-accessible
+ * @KDBUS_MAKE_ACCESS_WORLD:	Make the device node world-accessible
+ */
+enum kdbus_make_flags {
+	KDBUS_MAKE_ACCESS_GROUP		= 1 <<  0,
+	KDBUS_MAKE_ACCESS_WORLD		= 1 <<  1,
+};
+
+/**
+ * struct kdbus_cmd_make - struct to make a bus, an endpoint or a domain
+ * @size:		The total size of the struct
+ * @flags:		Properties for the bus/ep/domain to create
+ * @items:		Items describing details
+ *
+ * This structure is used with the KDBUS_CMD_BUS_MAKE, KDBUS_CMD_EP_MAKE and
+ * KDBUS_CMD_DOMAIN_MAKE ioctls.
+ */
+struct kdbus_cmd_make {
+	__u64 size;
+	__u64 flags;
+	struct kdbus_item items[0];
+} __attribute__((aligned(8)));
+
+/**
+ * enum kdbus_name_flags - properties of a well-known name
+ * @KDBUS_NAME_REPLACE_EXISTING:	Try to replace name of other connections
+ * @KDBUS_NAME_ALLOW_REPLACEMENT:	Allow the replacement of the name
+ * @KDBUS_NAME_QUEUE:			Name should be queued if busy
+ * @KDBUS_NAME_IN_QUEUE:		Name is queued
+ * @KDBUS_NAME_ACTIVATOR:		Name is owned by a activator connection
+ */
+enum kdbus_name_flags {
+	KDBUS_NAME_REPLACE_EXISTING	= 1 <<  0,
+	KDBUS_NAME_ALLOW_REPLACEMENT	= 1 <<  1,
+	KDBUS_NAME_QUEUE		= 1 <<  2,
+	KDBUS_NAME_IN_QUEUE		= 1 <<  3,
+	KDBUS_NAME_ACTIVATOR		= 1 <<  4,
+};
+
+/**
+ * struct kdbus_cmd_name - struct to describe a well-known name
+ * @size:		The total size of the struct
+ * @flags:		Flags for a name entry (KDBUS_NAME_*)
+ * @owner_id:		The current owner of the name. For requests,
+ *			privileged users may set this field to
+ *			(de)register names on behalf of other connections.
+ * @conn_flags:		The flags of the owning connection (KDBUS_HELLO_*)
+ * @name:		The well-known name
+ *
+ * This structure is used with the KDBUS_CMD_NAME_ACQUIRE ioctl.
+ */
+struct kdbus_cmd_name {
+	__u64 size;
+	__u64 flags;
+	__u64 owner_id;
+	__u64 conn_flags;
+	char name[0];
+} __attribute__((aligned(8)));
+
+/**
+ * enum kdbus_name_list_flags - what to include into the returned list
+ * @KDBUS_NAME_LIST_UNIQUE:	All active connections
+ * @KDBUS_NAME_LIST_NAMES:	All known well-known names
+ * @KDBUS_NAME_LIST_ACTIVATORS:	All activator connections
+ * @KDBUS_NAME_LIST_QUEUED:	All queued-up names
+ */
+enum kdbus_name_list_flags {
+	KDBUS_NAME_LIST_UNIQUE		= 1 <<  0,
+	KDBUS_NAME_LIST_NAMES		= 1 <<  1,
+	KDBUS_NAME_LIST_ACTIVATORS	= 1 <<  2,
+	KDBUS_NAME_LIST_QUEUED		= 1 <<  3,
+};
+
+/**
+ * struct kdbus_cmd_name_list - request a list of name entries
+ * @flags:		Flags for the query (KDBUS_NAME_LIST_*)
+ * @offset:		The returned offset in the caller's pool buffer.
+ *			The user must use KDBUS_CMD_FREE to free the
+ *			allocated memory.
+ *
+ * This structure is used with the KDBUS_CMD_NAME_LIST ioctl.
+ */
+struct kdbus_cmd_name_list {
+	__u64 flags;
+	__u64 offset;
+} __attribute__((aligned(8)));
+
+/**
+ * struct kdbus_name_list - information returned by KDBUS_CMD_NAME_LIST
+ * @size:		The total size of the structure
+ * @names:		A list of names
+ *
+ * Note that the user is responsible for freeing the allocated memory with
+ * the KDBUS_CMD_FREE ioctl.
+ */
+struct kdbus_name_list {
+	__u64 size;
+	struct kdbus_cmd_name names[0];
+};
+
+/**
+ * struct kdbus_cmd_conn_info - struct used for KDBUS_CMD_CONN_INFO ioctl
+ * @size:		The total size of the struct
+ * @flags:		KDBUS_ATTACH_* flags
+ * @id:			The 64-bit ID of the connection. If set to zero, passing
+ *			@name is required. kdbus will look up the name to
+ *			determine the ID in this case.
+ * @offset:		Returned offset in the caller's pool buffer where the
+ *			kdbus_conn_info struct result is stored. The user must
+ *			use KDBUS_CMD_FREE to free the allocated memory.
+ * @name:		The optional well-known name to look up. Only needed in
+ *			case @id is zero.
+ *
+ * On success, the KDBUS_CMD_CONN_INFO ioctl will return 0 and @offset will
+ * tell the user the offset in the connection pool buffer at which to find the
+ * result in a struct kdbus_conn_info.
+ */
+struct kdbus_cmd_conn_info {
+	__u64 size;
+	__u64 flags;
+	__u64 id;
+	__u64 offset;
+	char name[0];
+} __attribute__((aligned(8)));
+
+/**
+ * struct kdbus_conn_info - information returned by KDBUS_CMD_CONN_INFO
+ * @size:		The total size of the struct
+ * @id:			The connection's 64-bit ID
+ * @flags:		The connection's flags
+ * @items:		A list of struct kdbus_item
+ *
+ * Note that the user is responsible for freeing the allocated memory with
+ * the KDBUS_CMD_FREE ioctl.
+ */
+struct kdbus_conn_info {
+	__u64 size;
+	__u64 id;
+	__u64 flags;
+	struct kdbus_item items[0];
+};
+
+/**
+ * struct kdbus_cmd_update - update flags of a connection
+ * @size:		The total size of the struct
+ * @items:		A list of struct kdbus_item
+ *
+ * This struct is used with the KDBUS_CMD_CONN_UPDATE ioctl.
+ */
+struct kdbus_cmd_update {
+	__u64 size;
+	struct kdbus_item items[0];
+} __attribute__((aligned(8)));
+
+/**
+ * struct kdbus_cmd_match - struct to add or remove matches
+ * @size:		The total size of the struct
+ * @owner_id:		Privileged users may (de)register matches on behalf
+ *			of other peers
+ * @cookie:		Userspace supplied cookie. When removing, the cookie
+ *			identifies the match to remove
+ * @items:		A list of items for additional information
+ *
+ * This structure is used with the KDBUS_CMD_ADD_MATCH and
+ * KDBUS_CMD_REMOVE_MATCH ioctl.
+ */
+struct kdbus_cmd_match {
+	__u64 size;
+	__u64 owner_id;
+	__u64 cookie;
+	struct kdbus_item items[0];
+} __attribute__((aligned(8)));
+
+/**
+ * struct kdbus_cmd_memfd_make - create a kdbus memfd
+ * @size:		The total size of the struct
+ * @file_size:		The initial file size
+ * @fd:			The returned file descriptor number
+ * @__pad:		Padding to ensure proper alignement
+ * @items:		A list of items for additional information
+ *
+ * This structure is used with the KDBUS_CMD_MEMFD_NEW ioctl.
+ */
+struct kdbus_cmd_memfd_make {
+	__u64 size;
+	__u64 file_size;
+	int fd;
+	__u32 __pad;
+	struct kdbus_item items[0];
+} __attribute__((aligned(8)));
+
+/**
+ * enum kdbus_ioctl_type - Ioctl API
+ * @KDBUS_CMD_BUS_MAKE:		After opening the "control" device node, this
+ *				command creates a new bus with the specified
+ *				name. The bus is immediately shut down and
+ *				cleaned up when the opened "control" device node
+ *				is closed.
+ * @KDBUS_CMD_DOMAIN_MAKE:	Similar to KDBUS_CMD_BUS_MAKE, but it creates a
+ *				new kdbus domain.
+ * @KDBUS_CMD_EP_MAKE:		Creates a new named special endpoint to talk to
+ *				the bus. Such endpoints usually carry a more
+ *				restrictive policy and grant restricted access
+ *				to specific applications.
+ * @KDBUS_CMD_HELLO:		By opening the bus device node a connection is
+ *				created. After a HELLO the opened connection
+ *				becomes an active peer on the bus.
+ * @KDBUS_CMD_BYEBYE:		Disconnect a connection. If the connection's
+ *				message list is empty, the calls succeeds, and
+ *				the handle is rendered unusable. Otherwise,
+ *				-EAGAIN is returned without any further side-
+ *				effects.
+ * @KDBUS_CMD_MSG_SEND:		Send a message and pass data from userspace to
+ *				the kernel.
+ * @KDBUS_CMD_MSG_RECV:		Receive a message from the kernel which is
+ *				placed in the receiver's pool.
+ * @KDBUS_CMD_MSG_CANCEL:	Cancel a pending request of a message that
+ *				blocks while waiting for a reply. The parameter
+ *				denotes the cookie of the message in flight.
+ * @KDBUS_CMD_FREE:		Release the allocated memory in the receiver's
+ *				pool.
+ * @KDBUS_CMD_NAME_ACQUIRE:	Request a well-known bus name to associate with
+ *				the connection. Well-known names are used to
+ *				address a peer on the bus.
+ * @KDBUS_CMD_NAME_RELEASE:	Release a well-known name the connection
+ *				currently owns.
+ * @KDBUS_CMD_NAME_LIST:	Retrieve the list of all currently registered
+ *				well-known and unique names.
+ * @KDBUS_CMD_CONN_INFO:	Retrieve credentials and properties of the
+ *				initial creator of the connection. The data was
+ *				stored at registration time and does not
+ *				necessarily represent the connected process or
+ *				the actual state of the process.
+ * @KDBUS_CMD_CONN_UPDATE:	Update the properties of a connection. Used to
+ *				update the metadata subscription mask and
+ *				policy.
+ * @KDBUS_CMD_EP_UPDATE:	Update the properties of a custom enpoint. Used
+ *				to update the policy.
+ * @KDBUS_CMD_MATCH_ADD:	Install a match which broadcast messages should
+ *				be delivered to the connection.
+ * @KDBUS_CMD_MATCH_REMOVE:	Remove a current match for broadcast messages.
+ * @KDBUS_CMD_MEMFD_NEW:	Return a new file descriptor which provides an
+ *				anonymous shared memory file and which can be
+ *				used to pass around larger chunks of data.
+ *				Kdbus memfd files can be sealed, which allows
+ *				the receiver to trust the data it has received.
+ *				Kdbus memfd files expose only very limited
+ *				operations, they can be mmap()ed, seek()ed,
+ *				(p)read(v)() and (p)write(v)(); most other
+ *				common file operations are not implemented.
+ *				Special caution needs to be taken with
+ *				read(v)()/write(v)() on a shared file; the
+ *				underlying file position is always shared
+ *				between all users of the file and race against
+ *				each other, pread(v)()/pwrite(v)() avoid these
+ *				issues.
+ * @KDBUS_CMD_MEMFD_SIZE_GET:	Return the size of the underlying file, which
+ *				changes with write().
+ * @KDBUS_CMD_MEMFD_SIZE_SET:	Truncate the underlying file to the specified
+ *				size.
+ * @KDBUS_CMD_MEMFD_SEAL_GET:	Return the state of the file sealing.
+ * @KDBUS_CMD_MEMFD_SEAL_SET:	Seal or break a seal of the file. Only files
+ *				which are not shared with other processes and
+ *				which are currently not mapped can be sealed.
+ *				The current process needs to be the one and
+ *				single owner of the file, the sealing cannot
+ *				be changed as long as the file is shared.
+ */
+enum kdbus_ioctl_type {
+	KDBUS_CMD_BUS_MAKE =		_IOW(KDBUS_IOCTL_MAGIC, 0x00,
+					     struct kdbus_cmd_make),
+	KDBUS_CMD_DOMAIN_MAKE =		_IOW(KDBUS_IOCTL_MAGIC, 0x10,
+					     struct kdbus_cmd_make),
+	KDBUS_CMD_EP_MAKE =		_IOW(KDBUS_IOCTL_MAGIC, 0x20,
+					     struct kdbus_cmd_make),
+
+	KDBUS_CMD_HELLO =		_IOWR(KDBUS_IOCTL_MAGIC, 0x30,
+					      struct kdbus_cmd_hello),
+	KDBUS_CMD_BYEBYE =		_IO(KDBUS_IOCTL_MAGIC, 0x31),
+
+	KDBUS_CMD_MSG_SEND =		_IOWR(KDBUS_IOCTL_MAGIC, 0x40,
+					      struct kdbus_msg),
+	KDBUS_CMD_MSG_RECV =		_IOWR(KDBUS_IOCTL_MAGIC, 0x41,
+					      struct kdbus_cmd_recv),
+	KDBUS_CMD_MSG_CANCEL =		_IOW(KDBUS_IOCTL_MAGIC, 0x42, __u64 *),
+	KDBUS_CMD_FREE =		_IOW(KDBUS_IOCTL_MAGIC, 0x43, __u64 *),
+
+	KDBUS_CMD_NAME_ACQUIRE =	_IOWR(KDBUS_IOCTL_MAGIC, 0x50,
+					      struct kdbus_cmd_name),
+	KDBUS_CMD_NAME_RELEASE =	_IOW(KDBUS_IOCTL_MAGIC, 0x51,
+					     struct kdbus_cmd_name),
+	KDBUS_CMD_NAME_LIST =		_IOWR(KDBUS_IOCTL_MAGIC, 0x52,
+					     struct kdbus_cmd_name_list),
+
+	KDBUS_CMD_CONN_INFO =		_IOWR(KDBUS_IOCTL_MAGIC, 0x60,
+					      struct kdbus_cmd_conn_info),
+	KDBUS_CMD_CONN_UPDATE =		_IOW(KDBUS_IOCTL_MAGIC, 0x61,
+					     struct kdbus_cmd_update),
+
+	KDBUS_CMD_EP_UPDATE =		_IOW(KDBUS_IOCTL_MAGIC, 0x71,
+					     struct kdbus_cmd_update),
+
+	KDBUS_CMD_MATCH_ADD =		_IOW(KDBUS_IOCTL_MAGIC, 0x80,
+					     struct kdbus_cmd_match),
+	KDBUS_CMD_MATCH_REMOVE =	_IOW(KDBUS_IOCTL_MAGIC, 0x81,
+					     struct kdbus_cmd_match),
+
+	KDBUS_CMD_MEMFD_NEW =		_IOWR(KDBUS_IOCTL_MAGIC, 0xc0,
+					      struct kdbus_cmd_memfd_make),
+	KDBUS_CMD_MEMFD_SIZE_GET =	_IOR(KDBUS_IOCTL_MAGIC, 0xc1, __u64 *),
+	KDBUS_CMD_MEMFD_SIZE_SET =	_IOW(KDBUS_IOCTL_MAGIC, 0xc2, __u64 *),
+	KDBUS_CMD_MEMFD_SEAL_GET =	_IOR(KDBUS_IOCTL_MAGIC, 0xc3, int *),
+	KDBUS_CMD_MEMFD_SEAL_SET =	_IO(KDBUS_IOCTL_MAGIC, 0xc4),
+};
+
+/*
+ * errno - api error codes
+ * @E2BIG:		A message contains too many records or items.
+ * @EADDRINUSE:		A well-known bus name is already taken by another
+ *			connection.
+ * @EADDRNOTAVAIL:	A message flagged not to activate a service, addressed
+ *			a service which is not currently running.
+ * @EAGAIN:		No messages are queued at the moment.
+ * @EALREADY:		A requested name is already owned by the connection,
+ *			a connection is already disconnected, memfd is already
+ *			sealed or has the requested size.
+ * @EBADF:		File descriptors passed with the message are not valid.
+ * @EBADFD:		A bus connection is in a corrupted state.
+ * @EBADMSG:		Passed data contains a combination of conflicting or
+ *			inconsistent types.
+ * @EBUSY:		The user tried to say BYEBYE to a connection, but the
+ *			connection had a non-empty message list.
+ * @ECANCELED:		A synchronous message sending was cancelled.
+ * @ECONNRESET:		A connection is shut down, no further operations are
+ *			possible.
+ * @ECOMM:		A peer does not accept the file descriptors addressed
+ *			to it.
+ * @EDESTADDRREQ:	The well-known bus name is required but missing.
+ * @EDOM:		The size of data does not match the expectations. Used
+ *			for bloom bit field sizes.
+ * @EEXIST:		A requested domain, bus or endpoint with the same
+ *			name already exists.  A specific data type, which is
+ *			only expected once, is provided multiple times.
+ * @EFAULT:		The supplied memory could not be accessed, or the data
+ *			is not properly aligned.
+ * @EINVAL:		The provided data does not match its type or other
+ *			expectations, like a string which is not NUL terminated,
+ *			or a string length that points behind the first
+ *			\0-byte in the string.
+ * @EMEDIUMTYPE:	A file descriptor which is not a kdbus memfd was
+ *			refused to send as KDBUS_MSG_PAYLOAD_MEMFD.
+ * @EMFILE:		Too many file descriptors have been supplied with a
+ *			message.
+ *			Too many connections or buses are created for a given
+ *			user.
+ * @EMLINK:		Too many requests from this connection to other peers
+ *			are queued and waiting for a reply
+ * @EMSGSIZE:		The supplied data is larger than the allowed maximum
+ *			size.
+ * @ENAMETOOLONG:	The requested name is larger than the allowed maximum
+ *			size.
+ * @ENOBUFS:		There is no space left for the submitted data to fit
+ *			into the receiver's pool.
+ * @ENOENT:		The name to query information about is currently not on
+ *			the bus.
+ * @ENOMEM:		Out of memory.
+ * @ENOMSG:		The queue is not empty, but no message with a matching
+ *			priority is currently queued.
+ * @ENOSYS:		The requested functionality is not available.
+ * @ENOTSUPP:		The feature negotiation failed, a not supported feature
+ *			was requested, or an unknown item type was received.
+ * @ENOTTY:		An unknown ioctl command was received.
+ * @ENOTUNIQ:		A specific data type was addressed to a broadcast
+ *			address, but only direct addresses support this kind of
+ *			data.
+ * @ENXIO:		A unique address does not exist, or an offset in the
+ *			receiver's pool does not represent a queued message.
+ * @EPERM:		The policy prevented an operation. The requested
+ *			resource is owned by another entity.
+ * @EPIPE:		When sending a message, a synchronous reply from the
+ *			receiving connection was expected but the connection
+ *			died before answering.
+ * @ESHUTDOWN:		A domain, bus or endpoint is currently shutting down;
+ *			no further operations will be possible.
+ * @ESRCH:		A requested well-known bus name is not found.
+ * @ETIMEDOUT:		A synchronous wait for a message reply did not arrive
+ *			within the specified time frame.
+ * @ETXTBSY:		A kdbus memfd file cannot be sealed or the seal removed,
+ *			because it is shared with other processes or still
+ *			mmap()ed.
+ * @EXFULL:		The size limits in the pool are reached, no data of
+ *			the size tried to submit can be queued.
+ */
+#endif
diff --git a/glib/Makefile.am b/glib/Makefile.am
index d9892f6..4479ea2 100644
--- a/glib/Makefile.am
+++ b/glib/Makefile.am
@@ -160,6 +160,7 @@ libglib_2_0_la_SOURCES = 	\
 	gscripttable.h		\
 	gsequence.c		\
 	gshell.c		\
+	gsiphash.c		\
 	gslice.c		\
 	gslist.c		\
 	gstdio.c		\
@@ -290,6 +291,7 @@ glibsubinclude_HEADERS = \
 	gscanner.h	\
 	gsequence.h	\
 	gshell.h	\
+	gsiphash.h	\
 	gslice.h	\
 	gslist.h	\
 	gspawn.h	\
diff --git a/glib/glib.h b/glib/glib.h
index c7fc999..e83caa6 100644
--- a/glib/glib.h
+++ b/glib/glib.h
@@ -73,6 +73,7 @@
 #include <glib/gscanner.h>
 #include <glib/gsequence.h>
 #include <glib/gshell.h>
+#include <glib/gsiphash.h>
 #include <glib/gslice.h>
 #include <glib/gslist.h>
 #include <glib/gspawn.h>
diff --git a/glib/gsiphash.c b/glib/gsiphash.c
new file mode 100644
index 0000000..6cda0dd
--- /dev/null
+++ b/glib/gsiphash.c
@@ -0,0 +1,137 @@
+/*
+   SipHash reference C implementation
+
+   Written in 2012 by
+   Jean-Philippe Aumasson <jeanphilippe.aumasson@gmail.com>
+   Daniel J. Bernstein <djb@cr.yp.to>
+
+   To the extent possible under law, the author(s) have dedicated all copyright
+   and related and neighboring rights to this software to the public domain
+   worldwide. This software is distributed without any warranty.
+
+   You should have received a copy of the CC0 Public Domain Dedication along with
+   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
+
+*/
+
+#include "config.h"
+
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "gsiphash.h"
+
+typedef uint64_t u64;
+typedef uint32_t u32;
+typedef uint8_t u8;
+
+#define ROTL(x,b) (u64)( ((x) << (b)) | ( (x) >> (64 - (b))) )
+
+#define U32TO8_LE(p, v)         \
+    (p)[0] = (u8)((v)      ); (p)[1] = (u8)((v) >>  8); \
+    (p)[2] = (u8)((v) >> 16); (p)[3] = (u8)((v) >> 24);
+
+#define U64TO8_LE(p, v)         \
+  U32TO8_LE((p),     (u32)((v)      ));   \
+  U32TO8_LE((p) + 4, (u32)((v) >> 32));
+
+#define U8TO64_LE(p) \
+  (((u64)((p)[0])      ) | \
+   ((u64)((p)[1]) <<  8) | \
+   ((u64)((p)[2]) << 16) | \
+   ((u64)((p)[3]) << 24) | \
+   ((u64)((p)[4]) << 32) | \
+   ((u64)((p)[5]) << 40) | \
+   ((u64)((p)[6]) << 48) | \
+   ((u64)((p)[7]) << 56))
+
+#define SIPROUND            \
+  do {              \
+    v0 += v1; v1=ROTL(v1,13); v1 ^= v0; v0=ROTL(v0,32); \
+    v2 += v3; v3=ROTL(v3,16); v3 ^= v2;     \
+    v0 += v3; v3=ROTL(v3,21); v3 ^= v0;     \
+    v2 += v1; v1=ROTL(v1,17); v1 ^= v2; v2=ROTL(v2,32); \
+  } while(0)
+
+/* SipHash-2-4 */
+void g_siphash24(guint8 out[8], const void *_in, gsize inlen, const guint8 k[16])
+{
+  /* "somepseudorandomlygeneratedbytes" */
+  u64 v0 = 0x736f6d6570736575ULL;
+  u64 v1 = 0x646f72616e646f6dULL;
+  u64 v2 = 0x6c7967656e657261ULL;
+  u64 v3 = 0x7465646279746573ULL;
+  u64 b;
+  u64 k0 = U8TO64_LE( k );
+  u64 k1 = U8TO64_LE( k + 8 );
+  u64 m;
+  const u8 *in = _in;
+  const u8 *end = in + inlen - ( inlen % sizeof( u64 ) );
+  const int left = inlen & 7;
+  b = ( ( u64 )inlen ) << 56;
+  v3 ^= k1;
+  v2 ^= k0;
+  v1 ^= k1;
+  v0 ^= k0;
+
+  for ( ; in != end; in += 8 )
+  {
+    m = U8TO64_LE( in );
+#ifdef DEBUG
+    printf( "(%3d) v0 %08x %08x\n", ( int )inlen, ( u32 )( v0 >> 32 ), ( u32 )v0 );
+    printf( "(%3d) v1 %08x %08x\n", ( int )inlen, ( u32 )( v1 >> 32 ), ( u32 )v1 );
+    printf( "(%3d) v2 %08x %08x\n", ( int )inlen, ( u32 )( v2 >> 32 ), ( u32 )v2 );
+    printf( "(%3d) v3 %08x %08x\n", ( int )inlen, ( u32 )( v3 >> 32 ), ( u32 )v3 );
+    printf( "(%3d) compress %08x %08x\n", ( int )inlen, ( u32 )( m >> 32 ), ( u32 )m );
+#endif
+    v3 ^= m;
+    SIPROUND;
+    SIPROUND;
+    v0 ^= m;
+  }
+
+  switch( left )
+  {
+  case 7: b |= ( ( u64 )in[ 6] )  << 48;
+
+  case 6: b |= ( ( u64 )in[ 5] )  << 40;
+
+  case 5: b |= ( ( u64 )in[ 4] )  << 32;
+
+  case 4: b |= ( ( u64 )in[ 3] )  << 24;
+
+  case 3: b |= ( ( u64 )in[ 2] )  << 16;
+
+  case 2: b |= ( ( u64 )in[ 1] )  <<  8;
+
+  case 1: b |= ( ( u64 )in[ 0] ); break;
+
+  case 0: break;
+  }
+
+#ifdef DEBUG
+  printf( "(%3d) v0 %08x %08x\n", ( int )inlen, ( u32 )( v0 >> 32 ), ( u32 )v0 );
+  printf( "(%3d) v1 %08x %08x\n", ( int )inlen, ( u32 )( v1 >> 32 ), ( u32 )v1 );
+  printf( "(%3d) v2 %08x %08x\n", ( int )inlen, ( u32 )( v2 >> 32 ), ( u32 )v2 );
+  printf( "(%3d) v3 %08x %08x\n", ( int )inlen, ( u32 )( v3 >> 32 ), ( u32 )v3 );
+  printf( "(%3d) padding   %08x %08x\n", ( int )inlen, ( u32 )( b >> 32 ), ( u32 )b );
+#endif
+  v3 ^= b;
+  SIPROUND;
+  SIPROUND;
+  v0 ^= b;
+#ifdef DEBUG
+  printf( "(%3d) v0 %08x %08x\n", ( int )inlen, ( u32 )( v0 >> 32 ), ( u32 )v0 );
+  printf( "(%3d) v1 %08x %08x\n", ( int )inlen, ( u32 )( v1 >> 32 ), ( u32 )v1 );
+  printf( "(%3d) v2 %08x %08x\n", ( int )inlen, ( u32 )( v2 >> 32 ), ( u32 )v2 );
+  printf( "(%3d) v3 %08x %08x\n", ( int )inlen, ( u32 )( v3 >> 32 ), ( u32 )v3 );
+#endif
+  v2 ^= 0xff;
+  SIPROUND;
+  SIPROUND;
+  SIPROUND;
+  SIPROUND;
+  b = v0 ^ v1 ^ v2  ^ v3;
+  U64TO8_LE( out, b );
+}
diff --git a/glib/gsiphash.h b/glib/gsiphash.h
new file mode 100644
index 0000000..6040c75
--- /dev/null
+++ b/glib/gsiphash.h
@@ -0,0 +1,40 @@
+/*
+ *  Copyright (C) 2014 Samsung Electronics
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+
+ * Author: Lukasz Skalski       <l.skalski@samsung.com>
+ */
+
+#ifndef __G_SIPHASH_H__
+#define __G_SIPHASH_H__
+
+#if !defined (__GLIB_H_INSIDE__) && !defined (GLIB_COMPILATION)
+#error "Only <glib.h> can be included directly."
+#endif
+
+#include <glib/gtypes.h>
+
+G_BEGIN_DECLS
+
+GLIB_AVAILABLE_IN_ALL
+void    g_siphash24             (guint8         out[8],
+                                 const void    *_in,
+                                 gsize          inlen,
+                                 const guint8   k[16]);
+G_END_DECLS
+
+#endif /* __G_SIPHASH_H__ */
